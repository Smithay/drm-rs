/* automatically generated by rust-bindgen */

pub const __BITS_PER_LONG: u32 = 64;
pub const __FD_SETSIZE: u32 = 1024;
pub const _IOC_NRBITS: u32 = 8;
pub const _IOC_TYPEBITS: u32 = 8;
pub const _IOC_SIZEBITS: u32 = 14;
pub const _IOC_DIRBITS: u32 = 2;
pub const _IOC_NRMASK: u32 = 255;
pub const _IOC_TYPEMASK: u32 = 255;
pub const _IOC_SIZEMASK: u32 = 16383;
pub const _IOC_DIRMASK: u32 = 3;
pub const _IOC_NRSHIFT: u32 = 0;
pub const _IOC_TYPESHIFT: u32 = 8;
pub const _IOC_SIZESHIFT: u32 = 16;
pub const _IOC_DIRSHIFT: u32 = 30;
pub const _IOC_NONE: u32 = 0;
pub const _IOC_WRITE: u32 = 1;
pub const _IOC_READ: u32 = 2;
pub const IOC_IN: u32 = 1073741824;
pub const IOC_OUT: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const IOCSIZE_MASK: u32 = 1073676288;
pub const IOCSIZE_SHIFT: u32 = 16;
pub const DRM_NAME: &'static [u8; 4usize] = b"drm\0";
pub const DRM_MIN_ORDER: u32 = 5;
pub const DRM_MAX_ORDER: u32 = 22;
pub const DRM_RAM_PERCENT: u32 = 10;
pub const _DRM_LOCK_HELD: u32 = 2147483648;
pub const _DRM_LOCK_CONT: u32 = 1073741824;
pub const _DRM_VBLANK_HIGH_CRTC_SHIFT: u32 = 1;
pub const _DRM_PRE_MODESET: u32 = 1;
pub const _DRM_POST_MODESET: u32 = 2;
pub const DRM_CAP_DUMB_BUFFER: u32 = 1;
pub const DRM_CAP_VBLANK_HIGH_CRTC: u32 = 2;
pub const DRM_CAP_DUMB_PREFERRED_DEPTH: u32 = 3;
pub const DRM_CAP_DUMB_PREFER_SHADOW: u32 = 4;
pub const DRM_CAP_PRIME: u32 = 5;
pub const DRM_PRIME_CAP_IMPORT: u32 = 1;
pub const DRM_PRIME_CAP_EXPORT: u32 = 2;
pub const DRM_CAP_TIMESTAMP_MONOTONIC: u32 = 6;
pub const DRM_CAP_ASYNC_PAGE_FLIP: u32 = 7;
pub const DRM_CAP_CURSOR_WIDTH: u32 = 8;
pub const DRM_CAP_CURSOR_HEIGHT: u32 = 9;
pub const DRM_CAP_ADDFB2_MODIFIERS: u32 = 16;
pub const DRM_CAP_PAGE_FLIP_TARGET: u32 = 17;
pub const DRM_CAP_CRTC_IN_VBLANK_EVENT: u32 = 18;
pub const DRM_CAP_SYNCOBJ: u32 = 19;
pub const DRM_CAP_SYNCOBJ_TIMELINE: u32 = 20;
pub const DRM_CLIENT_CAP_STEREO_3D: u32 = 1;
pub const DRM_CLIENT_CAP_UNIVERSAL_PLANES: u32 = 2;
pub const DRM_CLIENT_CAP_ATOMIC: u32 = 3;
pub const DRM_CLIENT_CAP_ASPECT_RATIO: u32 = 4;
pub const DRM_CLIENT_CAP_WRITEBACK_CONNECTORS: u32 = 5;
pub const DRM_SYNCOBJ_CREATE_SIGNALED: u32 = 1;
pub const DRM_SYNCOBJ_FD_TO_HANDLE_FLAGS_IMPORT_SYNC_FILE: u32 = 1;
pub const DRM_SYNCOBJ_HANDLE_TO_FD_FLAGS_EXPORT_SYNC_FILE: u32 = 1;
pub const DRM_SYNCOBJ_WAIT_FLAGS_WAIT_ALL: u32 = 1;
pub const DRM_SYNCOBJ_WAIT_FLAGS_WAIT_FOR_SUBMIT: u32 = 2;
pub const DRM_SYNCOBJ_WAIT_FLAGS_WAIT_AVAILABLE: u32 = 4;
pub const DRM_CRTC_SEQUENCE_RELATIVE: u32 = 1;
pub const DRM_CRTC_SEQUENCE_NEXT_ON_MISS: u32 = 2;
pub const DRM_CONNECTOR_NAME_LEN: u32 = 32;
pub const DRM_DISPLAY_MODE_LEN: u32 = 32;
pub const DRM_PROP_NAME_LEN: u32 = 32;
pub const DRM_MODE_TYPE_BUILTIN: u32 = 1;
pub const DRM_MODE_TYPE_CLOCK_C: u32 = 3;
pub const DRM_MODE_TYPE_CRTC_C: u32 = 5;
pub const DRM_MODE_TYPE_PREFERRED: u32 = 8;
pub const DRM_MODE_TYPE_DEFAULT: u32 = 16;
pub const DRM_MODE_TYPE_USERDEF: u32 = 32;
pub const DRM_MODE_TYPE_DRIVER: u32 = 64;
pub const DRM_MODE_TYPE_ALL: u32 = 104;
pub const DRM_MODE_FLAG_PHSYNC: u32 = 1;
pub const DRM_MODE_FLAG_NHSYNC: u32 = 2;
pub const DRM_MODE_FLAG_PVSYNC: u32 = 4;
pub const DRM_MODE_FLAG_NVSYNC: u32 = 8;
pub const DRM_MODE_FLAG_INTERLACE: u32 = 16;
pub const DRM_MODE_FLAG_DBLSCAN: u32 = 32;
pub const DRM_MODE_FLAG_CSYNC: u32 = 64;
pub const DRM_MODE_FLAG_PCSYNC: u32 = 128;
pub const DRM_MODE_FLAG_NCSYNC: u32 = 256;
pub const DRM_MODE_FLAG_HSKEW: u32 = 512;
pub const DRM_MODE_FLAG_BCAST: u32 = 1024;
pub const DRM_MODE_FLAG_PIXMUX: u32 = 2048;
pub const DRM_MODE_FLAG_DBLCLK: u32 = 4096;
pub const DRM_MODE_FLAG_CLKDIV2: u32 = 8192;
pub const DRM_MODE_FLAG_3D_MASK: u32 = 507904;
pub const DRM_MODE_FLAG_3D_NONE: u32 = 0;
pub const DRM_MODE_FLAG_3D_FRAME_PACKING: u32 = 16384;
pub const DRM_MODE_FLAG_3D_FIELD_ALTERNATIVE: u32 = 32768;
pub const DRM_MODE_FLAG_3D_LINE_ALTERNATIVE: u32 = 49152;
pub const DRM_MODE_FLAG_3D_SIDE_BY_SIDE_FULL: u32 = 65536;
pub const DRM_MODE_FLAG_3D_L_DEPTH: u32 = 81920;
pub const DRM_MODE_FLAG_3D_L_DEPTH_GFX_GFX_DEPTH: u32 = 98304;
pub const DRM_MODE_FLAG_3D_TOP_AND_BOTTOM: u32 = 114688;
pub const DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF: u32 = 131072;
pub const DRM_MODE_PICTURE_ASPECT_NONE: u32 = 0;
pub const DRM_MODE_PICTURE_ASPECT_4_3: u32 = 1;
pub const DRM_MODE_PICTURE_ASPECT_16_9: u32 = 2;
pub const DRM_MODE_PICTURE_ASPECT_64_27: u32 = 3;
pub const DRM_MODE_PICTURE_ASPECT_256_135: u32 = 4;
pub const DRM_MODE_CONTENT_TYPE_NO_DATA: u32 = 0;
pub const DRM_MODE_CONTENT_TYPE_GRAPHICS: u32 = 1;
pub const DRM_MODE_CONTENT_TYPE_PHOTO: u32 = 2;
pub const DRM_MODE_CONTENT_TYPE_CINEMA: u32 = 3;
pub const DRM_MODE_CONTENT_TYPE_GAME: u32 = 4;
pub const DRM_MODE_FLAG_PIC_AR_MASK: u32 = 7864320;
pub const DRM_MODE_FLAG_PIC_AR_NONE: u32 = 0;
pub const DRM_MODE_FLAG_PIC_AR_4_3: u32 = 524288;
pub const DRM_MODE_FLAG_PIC_AR_16_9: u32 = 1048576;
pub const DRM_MODE_FLAG_PIC_AR_64_27: u32 = 1572864;
pub const DRM_MODE_FLAG_PIC_AR_256_135: u32 = 2097152;
pub const DRM_MODE_FLAG_ALL: u32 = 521215;
pub const DRM_MODE_DPMS_ON: u32 = 0;
pub const DRM_MODE_DPMS_STANDBY: u32 = 1;
pub const DRM_MODE_DPMS_SUSPEND: u32 = 2;
pub const DRM_MODE_DPMS_OFF: u32 = 3;
pub const DRM_MODE_SCALE_NONE: u32 = 0;
pub const DRM_MODE_SCALE_FULLSCREEN: u32 = 1;
pub const DRM_MODE_SCALE_CENTER: u32 = 2;
pub const DRM_MODE_SCALE_ASPECT: u32 = 3;
pub const DRM_MODE_DITHERING_OFF: u32 = 0;
pub const DRM_MODE_DITHERING_ON: u32 = 1;
pub const DRM_MODE_DITHERING_AUTO: u32 = 2;
pub const DRM_MODE_DIRTY_OFF: u32 = 0;
pub const DRM_MODE_DIRTY_ON: u32 = 1;
pub const DRM_MODE_DIRTY_ANNOTATE: u32 = 2;
pub const DRM_MODE_LINK_STATUS_GOOD: u32 = 0;
pub const DRM_MODE_LINK_STATUS_BAD: u32 = 1;
pub const DRM_MODE_ROTATE_0: u32 = 1;
pub const DRM_MODE_ROTATE_90: u32 = 2;
pub const DRM_MODE_ROTATE_180: u32 = 4;
pub const DRM_MODE_ROTATE_270: u32 = 8;
pub const DRM_MODE_ROTATE_MASK: u32 = 15;
pub const DRM_MODE_REFLECT_X: u32 = 16;
pub const DRM_MODE_REFLECT_Y: u32 = 32;
pub const DRM_MODE_REFLECT_MASK: u32 = 48;
pub const DRM_MODE_CONTENT_PROTECTION_UNDESIRED: u32 = 0;
pub const DRM_MODE_CONTENT_PROTECTION_DESIRED: u32 = 1;
pub const DRM_MODE_CONTENT_PROTECTION_ENABLED: u32 = 2;
pub const DRM_MODE_PRESENT_TOP_FIELD: u32 = 1;
pub const DRM_MODE_PRESENT_BOTTOM_FIELD: u32 = 2;
pub const DRM_MODE_ENCODER_NONE: u32 = 0;
pub const DRM_MODE_ENCODER_DAC: u32 = 1;
pub const DRM_MODE_ENCODER_TMDS: u32 = 2;
pub const DRM_MODE_ENCODER_LVDS: u32 = 3;
pub const DRM_MODE_ENCODER_TVDAC: u32 = 4;
pub const DRM_MODE_ENCODER_VIRTUAL: u32 = 5;
pub const DRM_MODE_ENCODER_DSI: u32 = 6;
pub const DRM_MODE_ENCODER_DPMST: u32 = 7;
pub const DRM_MODE_ENCODER_DPI: u32 = 8;
pub const DRM_MODE_CONNECTOR_Unknown: u32 = 0;
pub const DRM_MODE_CONNECTOR_VGA: u32 = 1;
pub const DRM_MODE_CONNECTOR_DVII: u32 = 2;
pub const DRM_MODE_CONNECTOR_DVID: u32 = 3;
pub const DRM_MODE_CONNECTOR_DVIA: u32 = 4;
pub const DRM_MODE_CONNECTOR_Composite: u32 = 5;
pub const DRM_MODE_CONNECTOR_SVIDEO: u32 = 6;
pub const DRM_MODE_CONNECTOR_LVDS: u32 = 7;
pub const DRM_MODE_CONNECTOR_Component: u32 = 8;
pub const DRM_MODE_CONNECTOR_9PinDIN: u32 = 9;
pub const DRM_MODE_CONNECTOR_DisplayPort: u32 = 10;
pub const DRM_MODE_CONNECTOR_HDMIA: u32 = 11;
pub const DRM_MODE_CONNECTOR_HDMIB: u32 = 12;
pub const DRM_MODE_CONNECTOR_TV: u32 = 13;
pub const DRM_MODE_CONNECTOR_eDP: u32 = 14;
pub const DRM_MODE_CONNECTOR_VIRTUAL: u32 = 15;
pub const DRM_MODE_CONNECTOR_DSI: u32 = 16;
pub const DRM_MODE_CONNECTOR_DPI: u32 = 17;
pub const DRM_MODE_CONNECTOR_WRITEBACK: u32 = 18;
pub const DRM_MODE_PROP_PENDING: u32 = 1;
pub const DRM_MODE_PROP_RANGE: u32 = 2;
pub const DRM_MODE_PROP_SIGNED_RANGE: u32 = 128;
pub const DRM_MODE_PROP_OBJECT: u32 = 64;
pub const DRM_MODE_PROP_IMMUTABLE: u32 = 4;
pub const DRM_MODE_PROP_ENUM: u32 = 8;
pub const DRM_MODE_PROP_BLOB: u32 = 16;
pub const DRM_MODE_PROP_BITMASK: u32 = 32;
pub const DRM_MODE_PROP_LEGACY_TYPE: u32 = 58;
pub const DRM_MODE_PROP_EXTENDED_TYPE: u32 = 65472;
pub const DRM_MODE_PROP_ATOMIC: u32 = 2147483648;
pub const DRM_MODE_OBJECT_CRTC: u32 = 3435973836;
pub const DRM_MODE_OBJECT_CONNECTOR: u32 = 3233857728;
pub const DRM_MODE_OBJECT_ENCODER: u32 = 3772834016;
pub const DRM_MODE_OBJECT_MODE: u32 = 3739147998;
pub const DRM_MODE_OBJECT_PROPERTY: u32 = 2964369584;
pub const DRM_MODE_OBJECT_FB: u32 = 4227595259;
pub const DRM_MODE_OBJECT_BLOB: u32 = 3149642683;
pub const DRM_MODE_OBJECT_PLANE: u32 = 4008636142;
pub const DRM_MODE_OBJECT_ANY: u32 = 0;
pub const DRM_MODE_FB_INTERLACED: u32 = 1;
pub const DRM_MODE_FB_MODIFIERS: u32 = 2;
pub const DRM_MODE_FB_DIRTY_ANNOTATE_COPY: u32 = 1;
pub const DRM_MODE_FB_DIRTY_ANNOTATE_FILL: u32 = 2;
pub const DRM_MODE_FB_DIRTY_FLAGS: u32 = 3;
pub const DRM_MODE_FB_DIRTY_MAX_CLIPS: u32 = 256;
pub const DRM_MODE_CURSOR_BO: u32 = 1;
pub const DRM_MODE_CURSOR_MOVE: u32 = 2;
pub const DRM_MODE_CURSOR_FLAGS: u32 = 3;
pub const DRM_MODE_PAGE_FLIP_EVENT: u32 = 1;
pub const DRM_MODE_PAGE_FLIP_ASYNC: u32 = 2;
pub const DRM_MODE_PAGE_FLIP_TARGET_ABSOLUTE: u32 = 4;
pub const DRM_MODE_PAGE_FLIP_TARGET_RELATIVE: u32 = 8;
pub const DRM_MODE_PAGE_FLIP_TARGET: u32 = 12;
pub const DRM_MODE_PAGE_FLIP_FLAGS: u32 = 15;
pub const DRM_MODE_ATOMIC_TEST_ONLY: u32 = 256;
pub const DRM_MODE_ATOMIC_NONBLOCK: u32 = 512;
pub const DRM_MODE_ATOMIC_ALLOW_MODESET: u32 = 1024;
pub const DRM_MODE_ATOMIC_FLAGS: u32 = 1795;
pub const FORMAT_BLOB_CURRENT: u32 = 1;
pub const DRM_IOCTL_BASE: u8 = 100u8;
pub const DRM_COMMAND_BASE: u32 = 64;
pub const DRM_COMMAND_END: u32 = 160;
pub const DRM_EVENT_VBLANK: u32 = 1;
pub const DRM_EVENT_FLIP_COMPLETE: u32 = 2;
pub const DRM_EVENT_CRTC_SEQUENCE: u32 = 3;
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_old_dev_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fsid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = ::std::os::raw::c_uint;
pub type drm_handle_t = ::std::os::raw::c_uint;
pub type drm_context_t = ::std::os::raw::c_uint;
pub type drm_drawable_t = ::std::os::raw::c_uint;
pub type drm_magic_t = ::std::os::raw::c_uint;
#[doc = " Cliprect."]
#[doc = ""]
#[doc = " \\warning: If you change this structure, make sure you change"]
#[doc = " XF86DRIClipRectRec in the server as well"]
#[doc = ""]
#[doc = " \\note KW: Actually it's illegal to change either for"]
#[doc = " backwards-compatibility reasons."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_clip_rect {
    pub x1: ::std::os::raw::c_ushort,
    pub y1: ::std::os::raw::c_ushort,
    pub x2: ::std::os::raw::c_ushort,
    pub y2: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_drm_clip_rect() {
    assert_eq!(
        ::std::mem::size_of::<drm_clip_rect>(),
        8usize,
        concat!("Size of: ", stringify!(drm_clip_rect))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_clip_rect>(),
        2usize,
        concat!("Alignment of ", stringify!(drm_clip_rect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_clip_rect>())).x1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_clip_rect),
            "::",
            stringify!(x1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_clip_rect>())).y1 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_clip_rect),
            "::",
            stringify!(y1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_clip_rect>())).x2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_clip_rect),
            "::",
            stringify!(x2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_clip_rect>())).y2 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_clip_rect),
            "::",
            stringify!(y2)
        )
    );
}
#[doc = " Drawable information."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_drawable_info {
    pub num_rects: ::std::os::raw::c_uint,
    pub rects: *mut drm_clip_rect,
}
#[test]
fn bindgen_test_layout_drm_drawable_info() {
    assert_eq!(
        ::std::mem::size_of::<drm_drawable_info>(),
        16usize,
        concat!("Size of: ", stringify!(drm_drawable_info))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_drawable_info>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_drawable_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_drawable_info>())).num_rects as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_drawable_info),
            "::",
            stringify!(num_rects)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_drawable_info>())).rects as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_drawable_info),
            "::",
            stringify!(rects)
        )
    );
}
impl Default for drm_drawable_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Texture region,"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_tex_region {
    pub next: ::std::os::raw::c_uchar,
    pub prev: ::std::os::raw::c_uchar,
    pub in_use: ::std::os::raw::c_uchar,
    pub padding: ::std::os::raw::c_uchar,
    pub age: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_drm_tex_region() {
    assert_eq!(
        ::std::mem::size_of::<drm_tex_region>(),
        8usize,
        concat!("Size of: ", stringify!(drm_tex_region))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_tex_region>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_tex_region))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_tex_region>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_tex_region),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_tex_region>())).prev as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_tex_region),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_tex_region>())).in_use as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_tex_region),
            "::",
            stringify!(in_use)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_tex_region>())).padding as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_tex_region),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_tex_region>())).age as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_tex_region),
            "::",
            stringify!(age)
        )
    );
}
#[doc = " Hardware lock."]
#[doc = ""]
#[doc = " The lock structure is a simple cache-line aligned integer.  To avoid"]
#[doc = " processor bus contention on a multiprocessor system, there should not be any"]
#[doc = " other data stored in the same cache line."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drm_hw_lock {
    #[doc = "< lock variable"]
    pub lock: ::std::os::raw::c_uint,
    #[doc = "< Pad to cache line"]
    pub padding: [::std::os::raw::c_char; 60usize],
}
#[test]
fn bindgen_test_layout_drm_hw_lock() {
    assert_eq!(
        ::std::mem::size_of::<drm_hw_lock>(),
        64usize,
        concat!("Size of: ", stringify!(drm_hw_lock))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_hw_lock>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_hw_lock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_hw_lock>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_hw_lock),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_hw_lock>())).padding as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_hw_lock),
            "::",
            stringify!(padding)
        )
    );
}
impl Default for drm_hw_lock {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " DRM_IOCTL_VERSION ioctl argument type."]
#[doc = ""]
#[doc = " \\sa drmGetVersion()."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_version {
    #[doc = "< Major version"]
    pub version_major: ::std::os::raw::c_int,
    #[doc = "< Minor version"]
    pub version_minor: ::std::os::raw::c_int,
    #[doc = "< Patch level"]
    pub version_patchlevel: ::std::os::raw::c_int,
    #[doc = "< Length of name buffer"]
    pub name_len: __kernel_size_t,
    #[doc = "< Name of driver"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "< Length of date buffer"]
    pub date_len: __kernel_size_t,
    #[doc = "< User-space buffer to hold date"]
    pub date: *mut ::std::os::raw::c_char,
    #[doc = "< Length of desc buffer"]
    pub desc_len: __kernel_size_t,
    #[doc = "< User-space buffer to hold desc"]
    pub desc: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_drm_version() {
    assert_eq!(
        ::std::mem::size_of::<drm_version>(),
        64usize,
        concat!("Size of: ", stringify!(drm_version))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_version>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_version))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_version>())).version_major as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_version),
            "::",
            stringify!(version_major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_version>())).version_minor as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_version),
            "::",
            stringify!(version_minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_version>())).version_patchlevel as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_version),
            "::",
            stringify!(version_patchlevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_version>())).name_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_version),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_version>())).name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_version),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_version>())).date_len as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_version),
            "::",
            stringify!(date_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_version>())).date as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_version),
            "::",
            stringify!(date)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_version>())).desc_len as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_version),
            "::",
            stringify!(desc_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_version>())).desc as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_version),
            "::",
            stringify!(desc)
        )
    );
}
impl Default for drm_version {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " DRM_IOCTL_GET_UNIQUE ioctl argument type."]
#[doc = ""]
#[doc = " \\sa drmGetBusid() and drmSetBusId()."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_unique {
    #[doc = "< Length of unique"]
    pub unique_len: __kernel_size_t,
    #[doc = "< Unique name for driver instantiation"]
    pub unique: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_drm_unique() {
    assert_eq!(
        ::std::mem::size_of::<drm_unique>(),
        16usize,
        concat!("Size of: ", stringify!(drm_unique))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_unique>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_unique))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_unique>())).unique_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_unique),
            "::",
            stringify!(unique_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_unique>())).unique as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_unique),
            "::",
            stringify!(unique)
        )
    );
}
impl Default for drm_unique {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_list {
    #[doc = "< Length of user-space structures"]
    pub count: ::std::os::raw::c_int,
    pub version: *mut drm_version,
}
#[test]
fn bindgen_test_layout_drm_list() {
    assert_eq!(
        ::std::mem::size_of::<drm_list>(),
        16usize,
        concat!("Size of: ", stringify!(drm_list))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_list>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_list>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_list),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_list>())).version as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_list),
            "::",
            stringify!(version)
        )
    );
}
impl Default for drm_list {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_block {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_drm_block() {
    assert_eq!(
        ::std::mem::size_of::<drm_block>(),
        4usize,
        concat!("Size of: ", stringify!(drm_block))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_block>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_block))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_block>())).unused as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_block),
            "::",
            stringify!(unused)
        )
    );
}
#[doc = " DRM_IOCTL_CONTROL ioctl argument type."]
#[doc = ""]
#[doc = " \\sa drmCtlInstHandler() and drmCtlUninstHandler()."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_control {
    pub func: drm_control__bindgen_ty_1,
    pub irq: ::std::os::raw::c_int,
}
pub const drm_control_DRM_ADD_COMMAND: drm_control__bindgen_ty_1 = 0;
pub const drm_control_DRM_RM_COMMAND: drm_control__bindgen_ty_1 = 1;
pub const drm_control_DRM_INST_HANDLER: drm_control__bindgen_ty_1 = 2;
pub const drm_control_DRM_UNINST_HANDLER: drm_control__bindgen_ty_1 = 3;
pub type drm_control__bindgen_ty_1 = u32;
#[test]
fn bindgen_test_layout_drm_control() {
    assert_eq!(
        ::std::mem::size_of::<drm_control>(),
        8usize,
        concat!("Size of: ", stringify!(drm_control))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_control>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_control))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_control>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_control),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_control>())).irq as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_control),
            "::",
            stringify!(irq)
        )
    );
}
impl Default for drm_control {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = "< WC (no caching), no core dump"]
pub const drm_map_type__DRM_FRAME_BUFFER: drm_map_type = 0;
#[doc = "< no caching, no core dump"]
pub const drm_map_type__DRM_REGISTERS: drm_map_type = 1;
#[doc = "< shared, cached"]
pub const drm_map_type__DRM_SHM: drm_map_type = 2;
#[doc = "< AGP/GART"]
pub const drm_map_type__DRM_AGP: drm_map_type = 3;
#[doc = "< Scatter/gather memory for PCI DMA"]
pub const drm_map_type__DRM_SCATTER_GATHER: drm_map_type = 4;
#[doc = "< Consistent memory for PCI DMA"]
pub const drm_map_type__DRM_CONSISTENT: drm_map_type = 5;
#[doc = " Type of memory to map."]
pub type drm_map_type = u32;
#[doc = "< Cannot be mapped to user-virtual"]
pub const drm_map_flags__DRM_RESTRICTED: drm_map_flags = 1;
pub const drm_map_flags__DRM_READ_ONLY: drm_map_flags = 2;
#[doc = "< shared, cached, locked"]
pub const drm_map_flags__DRM_LOCKED: drm_map_flags = 4;
#[doc = "< kernel requires access"]
pub const drm_map_flags__DRM_KERNEL: drm_map_flags = 8;
#[doc = "< use write-combining if available"]
pub const drm_map_flags__DRM_WRITE_COMBINING: drm_map_flags = 16;
#[doc = "< SHM page that contains lock"]
pub const drm_map_flags__DRM_CONTAINS_LOCK: drm_map_flags = 32;
#[doc = "< Removable mapping"]
pub const drm_map_flags__DRM_REMOVABLE: drm_map_flags = 64;
#[doc = "< Managed by driver"]
pub const drm_map_flags__DRM_DRIVER: drm_map_flags = 128;
#[doc = " Memory mapping flags."]
pub type drm_map_flags = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_ctx_priv_map {
    #[doc = "< Context requesting private mapping"]
    pub ctx_id: ::std::os::raw::c_uint,
    #[doc = "< Handle of map"]
    pub handle: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_drm_ctx_priv_map() {
    assert_eq!(
        ::std::mem::size_of::<drm_ctx_priv_map>(),
        16usize,
        concat!("Size of: ", stringify!(drm_ctx_priv_map))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_ctx_priv_map>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_ctx_priv_map))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_ctx_priv_map>())).ctx_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_ctx_priv_map),
            "::",
            stringify!(ctx_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_ctx_priv_map>())).handle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_ctx_priv_map),
            "::",
            stringify!(handle)
        )
    );
}
impl Default for drm_ctx_priv_map {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " DRM_IOCTL_GET_MAP, DRM_IOCTL_ADD_MAP and DRM_IOCTL_RM_MAP ioctls"]
#[doc = " argument type."]
#[doc = ""]
#[doc = " \\sa drmAddMap()."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_map {
    #[doc = "< Requested physical address (0 for SAREA)"]
    pub offset: ::std::os::raw::c_ulong,
    #[doc = "< Requested physical size (bytes)"]
    pub size: ::std::os::raw::c_ulong,
    #[doc = "< Type of memory to map"]
    pub type_: drm_map_type,
    #[doc = "< Flags"]
    pub flags: drm_map_flags,
    #[doc = "< User-space: \"Handle\" to pass to mmap() */"]
    pub handle: *mut ::std::os::raw::c_void,
    #[doc = "< MTRR slot used"]
    pub mtrr: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_drm_map() {
    assert_eq!(
        ::std::mem::size_of::<drm_map>(),
        40usize,
        concat!("Size of: ", stringify!(drm_map))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_map>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_map))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_map>())).offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_map),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_map>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_map),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_map>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_map),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_map>())).flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_map),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_map>())).handle as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_map),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_map>())).mtrr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_map),
            "::",
            stringify!(mtrr)
        )
    );
}
impl Default for drm_map {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " DRM_IOCTL_GET_CLIENT ioctl argument type."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_client {
    #[doc = "< Which client desired?"]
    pub idx: ::std::os::raw::c_int,
    #[doc = "< Is client authenticated?"]
    pub auth: ::std::os::raw::c_int,
    #[doc = "< Process ID"]
    pub pid: ::std::os::raw::c_ulong,
    #[doc = "< User ID"]
    pub uid: ::std::os::raw::c_ulong,
    #[doc = "< Magic"]
    pub magic: ::std::os::raw::c_ulong,
    #[doc = "< Ioctl count"]
    pub iocs: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_drm_client() {
    assert_eq!(
        ::std::mem::size_of::<drm_client>(),
        40usize,
        concat!("Size of: ", stringify!(drm_client))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_client>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_client))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_client>())).idx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_client),
            "::",
            stringify!(idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_client>())).auth as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_client),
            "::",
            stringify!(auth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_client>())).pid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_client),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_client>())).uid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_client),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_client>())).magic as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_client),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_client>())).iocs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_client),
            "::",
            stringify!(iocs)
        )
    );
}
pub const drm_stat_type__DRM_STAT_LOCK: drm_stat_type = 0;
pub const drm_stat_type__DRM_STAT_OPENS: drm_stat_type = 1;
pub const drm_stat_type__DRM_STAT_CLOSES: drm_stat_type = 2;
pub const drm_stat_type__DRM_STAT_IOCTLS: drm_stat_type = 3;
pub const drm_stat_type__DRM_STAT_LOCKS: drm_stat_type = 4;
pub const drm_stat_type__DRM_STAT_UNLOCKS: drm_stat_type = 5;
#[doc = "< Generic value"]
pub const drm_stat_type__DRM_STAT_VALUE: drm_stat_type = 6;
#[doc = "< Generic byte counter (1024bytes/K)"]
pub const drm_stat_type__DRM_STAT_BYTE: drm_stat_type = 7;
#[doc = "< Generic non-byte counter (1000/k)"]
pub const drm_stat_type__DRM_STAT_COUNT: drm_stat_type = 8;
#[doc = "< IRQ"]
pub const drm_stat_type__DRM_STAT_IRQ: drm_stat_type = 9;
#[doc = "< Primary DMA bytes"]
pub const drm_stat_type__DRM_STAT_PRIMARY: drm_stat_type = 10;
#[doc = "< Secondary DMA bytes"]
pub const drm_stat_type__DRM_STAT_SECONDARY: drm_stat_type = 11;
#[doc = "< DMA"]
pub const drm_stat_type__DRM_STAT_DMA: drm_stat_type = 12;
#[doc = "< Special DMA (e.g., priority or polled)"]
pub const drm_stat_type__DRM_STAT_SPECIAL: drm_stat_type = 13;
#[doc = "< Missed DMA opportunity"]
pub const drm_stat_type__DRM_STAT_MISSED: drm_stat_type = 14;
pub type drm_stat_type = u32;
#[doc = " DRM_IOCTL_GET_STATS ioctl argument type."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_stats {
    pub count: ::std::os::raw::c_ulong,
    pub data: [drm_stats__bindgen_ty_1; 15usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_stats__bindgen_ty_1 {
    pub value: ::std::os::raw::c_ulong,
    pub type_: drm_stat_type,
}
#[test]
fn bindgen_test_layout_drm_stats__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<drm_stats__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(drm_stats__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_stats__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_stats__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_stats__bindgen_ty_1>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_stats__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_stats__bindgen_ty_1>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_stats__bindgen_ty_1),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for drm_stats__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_drm_stats() {
    assert_eq!(
        ::std::mem::size_of::<drm_stats>(),
        248usize,
        concat!("Size of: ", stringify!(drm_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_stats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_stats>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_stats),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_stats>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_stats),
            "::",
            stringify!(data)
        )
    );
}
impl Default for drm_stats {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = "< Wait until hardware is ready for DMA"]
pub const drm_lock_flags__DRM_LOCK_READY: drm_lock_flags = 1;
#[doc = "< Wait until hardware quiescent"]
pub const drm_lock_flags__DRM_LOCK_QUIESCENT: drm_lock_flags = 2;
#[doc = "< Flush this context's DMA queue first"]
pub const drm_lock_flags__DRM_LOCK_FLUSH: drm_lock_flags = 4;
#[doc = "< Flush all DMA queues first"]
pub const drm_lock_flags__DRM_LOCK_FLUSH_ALL: drm_lock_flags = 8;
#[doc = "< Halt all current and future queues"]
pub const drm_lock_flags__DRM_HALT_ALL_QUEUES: drm_lock_flags = 16;
#[doc = "< Halt all current queues"]
pub const drm_lock_flags__DRM_HALT_CUR_QUEUES: drm_lock_flags = 32;
#[doc = " Hardware locking flags."]
pub type drm_lock_flags = u32;
#[doc = " DRM_IOCTL_LOCK, DRM_IOCTL_UNLOCK and DRM_IOCTL_FINISH ioctl argument type."]
#[doc = ""]
#[doc = " \\sa drmGetLock() and drmUnlock()."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_lock {
    pub context: ::std::os::raw::c_int,
    pub flags: drm_lock_flags,
}
#[test]
fn bindgen_test_layout_drm_lock() {
    assert_eq!(
        ::std::mem::size_of::<drm_lock>(),
        8usize,
        concat!("Size of: ", stringify!(drm_lock))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_lock>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_lock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_lock>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_lock),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_lock>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_lock),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for drm_lock {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = "<"]
#[doc = " Block until buffer dispatched."]
#[doc = ""]
#[doc = " \\note The buffer may not yet have"]
#[doc = " been processed by the hardware --"]
#[doc = " getting a hardware lock with the"]
#[doc = " hardware quiescent will ensure"]
#[doc = " that the buffer has been"]
#[doc = " processed."]
pub const drm_dma_flags__DRM_DMA_BLOCK: drm_dma_flags = 1;
#[doc = "< Dispatch while lock held"]
pub const drm_dma_flags__DRM_DMA_WHILE_LOCKED: drm_dma_flags = 2;
#[doc = "< High priority dispatch"]
pub const drm_dma_flags__DRM_DMA_PRIORITY: drm_dma_flags = 4;
#[doc = "< Wait for free buffers"]
pub const drm_dma_flags__DRM_DMA_WAIT: drm_dma_flags = 16;
#[doc = "< Smaller-than-requested buffers OK"]
pub const drm_dma_flags__DRM_DMA_SMALLER_OK: drm_dma_flags = 32;
#[doc = "< Larger-than-requested buffers OK"]
pub const drm_dma_flags__DRM_DMA_LARGER_OK: drm_dma_flags = 64;
#[doc = " DMA flags"]
#[doc = ""]
#[doc = " \\warning"]
#[doc = " These values \\e must match xf86drm.h."]
#[doc = ""]
#[doc = " \\sa drm_dma."]
pub type drm_dma_flags = u32;
#[doc = " DRM_IOCTL_ADD_BUFS and DRM_IOCTL_MARK_BUFS ioctl argument type."]
#[doc = ""]
#[doc = " \\sa drmAddBufs()."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_buf_desc {
    #[doc = "< Number of buffers of this size"]
    pub count: ::std::os::raw::c_int,
    #[doc = "< Size in bytes"]
    pub size: ::std::os::raw::c_int,
    #[doc = "< Low water mark"]
    pub low_mark: ::std::os::raw::c_int,
    #[doc = "< High water mark"]
    pub high_mark: ::std::os::raw::c_int,
    pub flags: drm_buf_desc__bindgen_ty_1,
    #[doc = "<"]
    #[doc = " Start address of where the AGP buffers are"]
    #[doc = " in the AGP aperture"]
    pub agp_start: ::std::os::raw::c_ulong,
}
#[doc = "< Align on page boundaries for DMA"]
pub const drm_buf_desc__DRM_PAGE_ALIGN: drm_buf_desc__bindgen_ty_1 = 1;
#[doc = "< Buffer is in AGP space"]
pub const drm_buf_desc__DRM_AGP_BUFFER: drm_buf_desc__bindgen_ty_1 = 2;
#[doc = "< Scatter/gather memory buffer"]
pub const drm_buf_desc__DRM_SG_BUFFER: drm_buf_desc__bindgen_ty_1 = 4;
#[doc = "< Buffer is in frame buffer"]
pub const drm_buf_desc__DRM_FB_BUFFER: drm_buf_desc__bindgen_ty_1 = 8;
#[doc = "< Map PCI DMA buffer read-only"]
pub const drm_buf_desc__DRM_PCI_BUFFER_RO: drm_buf_desc__bindgen_ty_1 = 16;
pub type drm_buf_desc__bindgen_ty_1 = u32;
#[test]
fn bindgen_test_layout_drm_buf_desc() {
    assert_eq!(
        ::std::mem::size_of::<drm_buf_desc>(),
        32usize,
        concat!("Size of: ", stringify!(drm_buf_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_buf_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_buf_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_buf_desc>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_buf_desc),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_buf_desc>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_buf_desc),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_buf_desc>())).low_mark as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_buf_desc),
            "::",
            stringify!(low_mark)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_buf_desc>())).high_mark as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_buf_desc),
            "::",
            stringify!(high_mark)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_buf_desc>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_buf_desc),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_buf_desc>())).agp_start as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_buf_desc),
            "::",
            stringify!(agp_start)
        )
    );
}
impl Default for drm_buf_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " DRM_IOCTL_INFO_BUFS ioctl argument type."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_buf_info {
    #[doc = "< Entries in list"]
    pub count: ::std::os::raw::c_int,
    pub list: *mut drm_buf_desc,
}
#[test]
fn bindgen_test_layout_drm_buf_info() {
    assert_eq!(
        ::std::mem::size_of::<drm_buf_info>(),
        16usize,
        concat!("Size of: ", stringify!(drm_buf_info))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_buf_info>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_buf_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_buf_info>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_buf_info),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_buf_info>())).list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_buf_info),
            "::",
            stringify!(list)
        )
    );
}
impl Default for drm_buf_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " DRM_IOCTL_FREE_BUFS ioctl argument type."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_buf_free {
    pub count: ::std::os::raw::c_int,
    pub list: *mut ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_drm_buf_free() {
    assert_eq!(
        ::std::mem::size_of::<drm_buf_free>(),
        16usize,
        concat!("Size of: ", stringify!(drm_buf_free))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_buf_free>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_buf_free))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_buf_free>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_buf_free),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_buf_free>())).list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_buf_free),
            "::",
            stringify!(list)
        )
    );
}
impl Default for drm_buf_free {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " Buffer information"]
#[doc = ""]
#[doc = " \\sa drm_buf_map."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_buf_pub {
    #[doc = "< Index into the master buffer list"]
    pub idx: ::std::os::raw::c_int,
    #[doc = "< Buffer size"]
    pub total: ::std::os::raw::c_int,
    #[doc = "< Amount of buffer in use (for DMA)"]
    pub used: ::std::os::raw::c_int,
    #[doc = "< Address of buffer"]
    pub address: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_drm_buf_pub() {
    assert_eq!(
        ::std::mem::size_of::<drm_buf_pub>(),
        24usize,
        concat!("Size of: ", stringify!(drm_buf_pub))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_buf_pub>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_buf_pub))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_buf_pub>())).idx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_buf_pub),
            "::",
            stringify!(idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_buf_pub>())).total as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_buf_pub),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_buf_pub>())).used as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_buf_pub),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_buf_pub>())).address as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_buf_pub),
            "::",
            stringify!(address)
        )
    );
}
impl Default for drm_buf_pub {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " DRM_IOCTL_MAP_BUFS ioctl argument type."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_buf_map {
    #[doc = "< Length of the buffer list"]
    pub count: ::std::os::raw::c_int,
    #[doc = "< Mmap'd area in user-virtual"]
    pub virtual_: *mut ::std::os::raw::c_void,
    #[doc = "< Buffer information"]
    pub list: *mut drm_buf_pub,
}
#[test]
fn bindgen_test_layout_drm_buf_map() {
    assert_eq!(
        ::std::mem::size_of::<drm_buf_map>(),
        24usize,
        concat!("Size of: ", stringify!(drm_buf_map))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_buf_map>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_buf_map))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_buf_map>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_buf_map),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_buf_map>())).virtual_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_buf_map),
            "::",
            stringify!(virtual_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_buf_map>())).list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_buf_map),
            "::",
            stringify!(list)
        )
    );
}
impl Default for drm_buf_map {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " DRM_IOCTL_DMA ioctl argument type."]
#[doc = ""]
#[doc = " Indices here refer to the offset into the buffer list in drm_buf_get."]
#[doc = ""]
#[doc = " \\sa drmDMA()."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_dma {
    #[doc = "< Context handle"]
    pub context: ::std::os::raw::c_int,
    #[doc = "< Number of buffers to send"]
    pub send_count: ::std::os::raw::c_int,
    #[doc = "< List of handles to buffers"]
    pub send_indices: *mut ::std::os::raw::c_int,
    #[doc = "< Lengths of data to send"]
    pub send_sizes: *mut ::std::os::raw::c_int,
    #[doc = "< Flags"]
    pub flags: drm_dma_flags,
    #[doc = "< Number of buffers requested"]
    pub request_count: ::std::os::raw::c_int,
    #[doc = "< Desired size for buffers"]
    pub request_size: ::std::os::raw::c_int,
    #[doc = "< Buffer information"]
    pub request_indices: *mut ::std::os::raw::c_int,
    pub request_sizes: *mut ::std::os::raw::c_int,
    #[doc = "< Number of buffers granted"]
    pub granted_count: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_drm_dma() {
    assert_eq!(
        ::std::mem::size_of::<drm_dma>(),
        64usize,
        concat!("Size of: ", stringify!(drm_dma))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_dma>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_dma))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_dma>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_dma),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_dma>())).send_count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_dma),
            "::",
            stringify!(send_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_dma>())).send_indices as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_dma),
            "::",
            stringify!(send_indices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_dma>())).send_sizes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_dma),
            "::",
            stringify!(send_sizes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_dma>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_dma),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_dma>())).request_count as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_dma),
            "::",
            stringify!(request_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_dma>())).request_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_dma),
            "::",
            stringify!(request_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_dma>())).request_indices as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_dma),
            "::",
            stringify!(request_indices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_dma>())).request_sizes as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_dma),
            "::",
            stringify!(request_sizes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_dma>())).granted_count as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_dma),
            "::",
            stringify!(granted_count)
        )
    );
}
impl Default for drm_dma {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const drm_ctx_flags__DRM_CONTEXT_PRESERVED: drm_ctx_flags = 1;
pub const drm_ctx_flags__DRM_CONTEXT_2DONLY: drm_ctx_flags = 2;
pub type drm_ctx_flags = u32;
#[doc = " DRM_IOCTL_ADD_CTX ioctl argument type."]
#[doc = ""]
#[doc = " \\sa drmCreateContext() and drmDestroyContext()."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_ctx {
    pub handle: drm_context_t,
    pub flags: drm_ctx_flags,
}
#[test]
fn bindgen_test_layout_drm_ctx() {
    assert_eq!(
        ::std::mem::size_of::<drm_ctx>(),
        8usize,
        concat!("Size of: ", stringify!(drm_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_ctx>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_ctx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_ctx>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_ctx),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_ctx>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_ctx),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for drm_ctx {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " DRM_IOCTL_RES_CTX ioctl argument type."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_ctx_res {
    pub count: ::std::os::raw::c_int,
    pub contexts: *mut drm_ctx,
}
#[test]
fn bindgen_test_layout_drm_ctx_res() {
    assert_eq!(
        ::std::mem::size_of::<drm_ctx_res>(),
        16usize,
        concat!("Size of: ", stringify!(drm_ctx_res))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_ctx_res>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_ctx_res))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_ctx_res>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_ctx_res),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_ctx_res>())).contexts as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_ctx_res),
            "::",
            stringify!(contexts)
        )
    );
}
impl Default for drm_ctx_res {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " DRM_IOCTL_ADD_DRAW and DRM_IOCTL_RM_DRAW ioctl argument type."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_draw {
    pub handle: drm_drawable_t,
}
#[test]
fn bindgen_test_layout_drm_draw() {
    assert_eq!(
        ::std::mem::size_of::<drm_draw>(),
        4usize,
        concat!("Size of: ", stringify!(drm_draw))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_draw>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_draw))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_draw>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_draw),
            "::",
            stringify!(handle)
        )
    );
}
pub const drm_drawable_info_type_t_DRM_DRAWABLE_CLIPRECTS: drm_drawable_info_type_t = 0;
#[doc = " DRM_IOCTL_UPDATE_DRAW ioctl argument type."]
pub type drm_drawable_info_type_t = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_update_draw {
    pub handle: drm_drawable_t,
    pub type_: ::std::os::raw::c_uint,
    pub num: ::std::os::raw::c_uint,
    pub data: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drm_update_draw() {
    assert_eq!(
        ::std::mem::size_of::<drm_update_draw>(),
        24usize,
        concat!("Size of: ", stringify!(drm_update_draw))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_update_draw>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_update_draw))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_update_draw>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_update_draw),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_update_draw>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_update_draw),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_update_draw>())).num as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_update_draw),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_update_draw>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_update_draw),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " DRM_IOCTL_GET_MAGIC and DRM_IOCTL_AUTH_MAGIC ioctl argument type."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_auth {
    pub magic: drm_magic_t,
}
#[test]
fn bindgen_test_layout_drm_auth() {
    assert_eq!(
        ::std::mem::size_of::<drm_auth>(),
        4usize,
        concat!("Size of: ", stringify!(drm_auth))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_auth>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_auth))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_auth>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_auth),
            "::",
            stringify!(magic)
        )
    );
}
#[doc = " DRM_IOCTL_IRQ_BUSID ioctl argument type."]
#[doc = ""]
#[doc = " \\sa drmGetInterruptFromBusID()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_irq_busid {
    #[doc = "< IRQ number"]
    pub irq: ::std::os::raw::c_int,
    #[doc = "< bus number"]
    pub busnum: ::std::os::raw::c_int,
    #[doc = "< device number"]
    pub devnum: ::std::os::raw::c_int,
    #[doc = "< function number"]
    pub funcnum: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_drm_irq_busid() {
    assert_eq!(
        ::std::mem::size_of::<drm_irq_busid>(),
        16usize,
        concat!("Size of: ", stringify!(drm_irq_busid))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_irq_busid>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_irq_busid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_irq_busid>())).irq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_irq_busid),
            "::",
            stringify!(irq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_irq_busid>())).busnum as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_irq_busid),
            "::",
            stringify!(busnum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_irq_busid>())).devnum as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_irq_busid),
            "::",
            stringify!(devnum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_irq_busid>())).funcnum as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_irq_busid),
            "::",
            stringify!(funcnum)
        )
    );
}
#[doc = "< Wait for specific vblank sequence number"]
pub const drm_vblank_seq_type__DRM_VBLANK_ABSOLUTE: drm_vblank_seq_type = 0;
#[doc = "< Wait for given number of vblanks"]
pub const drm_vblank_seq_type__DRM_VBLANK_RELATIVE: drm_vblank_seq_type = 1;
pub const drm_vblank_seq_type__DRM_VBLANK_HIGH_CRTC_MASK: drm_vblank_seq_type = 62;
#[doc = "< Send event instead of blocking"]
pub const drm_vblank_seq_type__DRM_VBLANK_EVENT: drm_vblank_seq_type = 67108864;
#[doc = "< Scheduled buffer swap should flip"]
pub const drm_vblank_seq_type__DRM_VBLANK_FLIP: drm_vblank_seq_type = 134217728;
#[doc = "< If missed, wait for next vblank"]
pub const drm_vblank_seq_type__DRM_VBLANK_NEXTONMISS: drm_vblank_seq_type = 268435456;
#[doc = "< Secondary display controller"]
pub const drm_vblank_seq_type__DRM_VBLANK_SECONDARY: drm_vblank_seq_type = 536870912;
#[doc = "< Send signal instead of blocking, unsupported"]
pub const drm_vblank_seq_type__DRM_VBLANK_SIGNAL: drm_vblank_seq_type = 1073741824;
pub type drm_vblank_seq_type = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_wait_vblank_request {
    pub type_: drm_vblank_seq_type,
    pub sequence: ::std::os::raw::c_uint,
    pub signal: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_drm_wait_vblank_request() {
    assert_eq!(
        ::std::mem::size_of::<drm_wait_vblank_request>(),
        16usize,
        concat!("Size of: ", stringify!(drm_wait_vblank_request))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_wait_vblank_request>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_wait_vblank_request))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_wait_vblank_request>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_wait_vblank_request),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_wait_vblank_request>())).sequence as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_wait_vblank_request),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_wait_vblank_request>())).signal as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_wait_vblank_request),
            "::",
            stringify!(signal)
        )
    );
}
impl Default for drm_wait_vblank_request {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_wait_vblank_reply {
    pub type_: drm_vblank_seq_type,
    pub sequence: ::std::os::raw::c_uint,
    pub tval_sec: ::std::os::raw::c_long,
    pub tval_usec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_drm_wait_vblank_reply() {
    assert_eq!(
        ::std::mem::size_of::<drm_wait_vblank_reply>(),
        24usize,
        concat!("Size of: ", stringify!(drm_wait_vblank_reply))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_wait_vblank_reply>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_wait_vblank_reply))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_wait_vblank_reply>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_wait_vblank_reply),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_wait_vblank_reply>())).sequence as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_wait_vblank_reply),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_wait_vblank_reply>())).tval_sec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_wait_vblank_reply),
            "::",
            stringify!(tval_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_wait_vblank_reply>())).tval_usec as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_wait_vblank_reply),
            "::",
            stringify!(tval_usec)
        )
    );
}
impl Default for drm_wait_vblank_reply {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " DRM_IOCTL_WAIT_VBLANK ioctl argument type."]
#[doc = ""]
#[doc = " \\sa drmWaitVBlank()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union drm_wait_vblank {
    pub request: drm_wait_vblank_request,
    pub reply: drm_wait_vblank_reply,
    _bindgen_union_align: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_drm_wait_vblank() {
    assert_eq!(
        ::std::mem::size_of::<drm_wait_vblank>(),
        24usize,
        concat!("Size of: ", stringify!(drm_wait_vblank))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_wait_vblank>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_wait_vblank))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_wait_vblank>())).request as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_wait_vblank),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_wait_vblank>())).reply as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_wait_vblank),
            "::",
            stringify!(reply)
        )
    );
}
impl Default for drm_wait_vblank {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " DRM_IOCTL_MODESET_CTL ioctl argument type"]
#[doc = ""]
#[doc = " \\sa drmModesetCtl()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_modeset_ctl {
    pub crtc: __u32,
    pub cmd: __u32,
}
#[test]
fn bindgen_test_layout_drm_modeset_ctl() {
    assert_eq!(
        ::std::mem::size_of::<drm_modeset_ctl>(),
        8usize,
        concat!("Size of: ", stringify!(drm_modeset_ctl))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_modeset_ctl>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_modeset_ctl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_modeset_ctl>())).crtc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_modeset_ctl),
            "::",
            stringify!(crtc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_modeset_ctl>())).cmd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_modeset_ctl),
            "::",
            stringify!(cmd)
        )
    );
}
#[doc = " DRM_IOCTL_AGP_ENABLE ioctl argument type."]
#[doc = ""]
#[doc = " \\sa drmAgpEnable()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_agp_mode {
    #[doc = "< AGP mode"]
    pub mode: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_drm_agp_mode() {
    assert_eq!(
        ::std::mem::size_of::<drm_agp_mode>(),
        8usize,
        concat!("Size of: ", stringify!(drm_agp_mode))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_agp_mode>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_agp_mode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_agp_mode>())).mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_agp_mode),
            "::",
            stringify!(mode)
        )
    );
}
#[doc = " DRM_IOCTL_AGP_ALLOC and DRM_IOCTL_AGP_FREE ioctls argument type."]
#[doc = ""]
#[doc = " \\sa drmAgpAlloc() and drmAgpFree()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_agp_buffer {
    #[doc = "< In bytes -- will round to page boundary"]
    pub size: ::std::os::raw::c_ulong,
    #[doc = "< Used for binding / unbinding"]
    pub handle: ::std::os::raw::c_ulong,
    #[doc = "< Type of memory to allocate"]
    pub type_: ::std::os::raw::c_ulong,
    #[doc = "< Physical used by i810"]
    pub physical: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_drm_agp_buffer() {
    assert_eq!(
        ::std::mem::size_of::<drm_agp_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(drm_agp_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_agp_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_agp_buffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_agp_buffer>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_agp_buffer),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_agp_buffer>())).handle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_agp_buffer),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_agp_buffer>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_agp_buffer),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_agp_buffer>())).physical as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_agp_buffer),
            "::",
            stringify!(physical)
        )
    );
}
#[doc = " DRM_IOCTL_AGP_BIND and DRM_IOCTL_AGP_UNBIND ioctls argument type."]
#[doc = ""]
#[doc = " \\sa drmAgpBind() and drmAgpUnbind()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_agp_binding {
    #[doc = "< From drm_agp_buffer"]
    pub handle: ::std::os::raw::c_ulong,
    #[doc = "< In bytes -- will round to page boundary"]
    pub offset: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_drm_agp_binding() {
    assert_eq!(
        ::std::mem::size_of::<drm_agp_binding>(),
        16usize,
        concat!("Size of: ", stringify!(drm_agp_binding))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_agp_binding>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_agp_binding))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_agp_binding>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_agp_binding),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_agp_binding>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_agp_binding),
            "::",
            stringify!(offset)
        )
    );
}
#[doc = " DRM_IOCTL_AGP_INFO ioctl argument type."]
#[doc = ""]
#[doc = " \\sa drmAgpVersionMajor(), drmAgpVersionMinor(), drmAgpGetMode(),"]
#[doc = " drmAgpBase(), drmAgpSize(), drmAgpMemoryUsed(), drmAgpMemoryAvail(),"]
#[doc = " drmAgpVendorId() and drmAgpDeviceId()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_agp_info {
    pub agp_version_major: ::std::os::raw::c_int,
    pub agp_version_minor: ::std::os::raw::c_int,
    pub mode: ::std::os::raw::c_ulong,
    pub aperture_base: ::std::os::raw::c_ulong,
    pub aperture_size: ::std::os::raw::c_ulong,
    pub memory_allowed: ::std::os::raw::c_ulong,
    pub memory_used: ::std::os::raw::c_ulong,
    pub id_vendor: ::std::os::raw::c_ushort,
    pub id_device: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_drm_agp_info() {
    assert_eq!(
        ::std::mem::size_of::<drm_agp_info>(),
        56usize,
        concat!("Size of: ", stringify!(drm_agp_info))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_agp_info>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_agp_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_agp_info>())).agp_version_major as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_agp_info),
            "::",
            stringify!(agp_version_major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_agp_info>())).agp_version_minor as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_agp_info),
            "::",
            stringify!(agp_version_minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_agp_info>())).mode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_agp_info),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_agp_info>())).aperture_base as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_agp_info),
            "::",
            stringify!(aperture_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_agp_info>())).aperture_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_agp_info),
            "::",
            stringify!(aperture_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_agp_info>())).memory_allowed as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_agp_info),
            "::",
            stringify!(memory_allowed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_agp_info>())).memory_used as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_agp_info),
            "::",
            stringify!(memory_used)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_agp_info>())).id_vendor as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_agp_info),
            "::",
            stringify!(id_vendor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_agp_info>())).id_device as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_agp_info),
            "::",
            stringify!(id_device)
        )
    );
}
#[doc = " DRM_IOCTL_SG_ALLOC ioctl argument type."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_scatter_gather {
    #[doc = "< In bytes -- will round to page boundary"]
    pub size: ::std::os::raw::c_ulong,
    #[doc = "< Used for mapping / unmapping"]
    pub handle: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_drm_scatter_gather() {
    assert_eq!(
        ::std::mem::size_of::<drm_scatter_gather>(),
        16usize,
        concat!("Size of: ", stringify!(drm_scatter_gather))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_scatter_gather>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_scatter_gather))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_scatter_gather>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_scatter_gather),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_scatter_gather>())).handle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_scatter_gather),
            "::",
            stringify!(handle)
        )
    );
}
#[doc = " DRM_IOCTL_SET_VERSION ioctl argument type."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_set_version {
    pub drm_di_major: ::std::os::raw::c_int,
    pub drm_di_minor: ::std::os::raw::c_int,
    pub drm_dd_major: ::std::os::raw::c_int,
    pub drm_dd_minor: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_drm_set_version() {
    assert_eq!(
        ::std::mem::size_of::<drm_set_version>(),
        16usize,
        concat!("Size of: ", stringify!(drm_set_version))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_set_version>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_set_version))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_set_version>())).drm_di_major as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_set_version),
            "::",
            stringify!(drm_di_major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_set_version>())).drm_di_minor as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_set_version),
            "::",
            stringify!(drm_di_minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_set_version>())).drm_dd_major as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_set_version),
            "::",
            stringify!(drm_dd_major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_set_version>())).drm_dd_minor as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_set_version),
            "::",
            stringify!(drm_dd_minor)
        )
    );
}
#[doc = " DRM_IOCTL_GEM_CLOSE ioctl argument type"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_gem_close {
    #[doc = " Handle of the object to be closed."]
    pub handle: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_drm_gem_close() {
    assert_eq!(
        ::std::mem::size_of::<drm_gem_close>(),
        8usize,
        concat!("Size of: ", stringify!(drm_gem_close))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_gem_close>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_gem_close))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_gem_close>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_gem_close),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_gem_close>())).pad as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_gem_close),
            "::",
            stringify!(pad)
        )
    );
}
#[doc = " DRM_IOCTL_GEM_FLINK ioctl argument type"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_gem_flink {
    #[doc = " Handle for the object being named"]
    pub handle: __u32,
    #[doc = " Returned global name"]
    pub name: __u32,
}
#[test]
fn bindgen_test_layout_drm_gem_flink() {
    assert_eq!(
        ::std::mem::size_of::<drm_gem_flink>(),
        8usize,
        concat!("Size of: ", stringify!(drm_gem_flink))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_gem_flink>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_gem_flink))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_gem_flink>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_gem_flink),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_gem_flink>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_gem_flink),
            "::",
            stringify!(name)
        )
    );
}
#[doc = " DRM_IOCTL_GEM_OPEN ioctl argument type"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_gem_open {
    #[doc = " Name of object being opened"]
    pub name: __u32,
    #[doc = " Returned handle for the object"]
    pub handle: __u32,
    #[doc = " Returned size of the object"]
    pub size: __u64,
}
#[test]
fn bindgen_test_layout_drm_gem_open() {
    assert_eq!(
        ::std::mem::size_of::<drm_gem_open>(),
        16usize,
        concat!("Size of: ", stringify!(drm_gem_open))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_gem_open>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_gem_open))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_gem_open>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_gem_open),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_gem_open>())).handle as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_gem_open),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_gem_open>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_gem_open),
            "::",
            stringify!(size)
        )
    );
}
#[doc = " DRM_IOCTL_GET_CAP ioctl argument type"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_get_cap {
    pub capability: __u64,
    pub value: __u64,
}
#[test]
fn bindgen_test_layout_drm_get_cap() {
    assert_eq!(
        ::std::mem::size_of::<drm_get_cap>(),
        16usize,
        concat!("Size of: ", stringify!(drm_get_cap))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_get_cap>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_get_cap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_get_cap>())).capability as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_get_cap),
            "::",
            stringify!(capability)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_get_cap>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_get_cap),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " DRM_IOCTL_SET_CLIENT_CAP ioctl argument type"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_set_client_cap {
    pub capability: __u64,
    pub value: __u64,
}
#[test]
fn bindgen_test_layout_drm_set_client_cap() {
    assert_eq!(
        ::std::mem::size_of::<drm_set_client_cap>(),
        16usize,
        concat!("Size of: ", stringify!(drm_set_client_cap))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_set_client_cap>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_set_client_cap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_set_client_cap>())).capability as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_set_client_cap),
            "::",
            stringify!(capability)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_set_client_cap>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_set_client_cap),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_prime_handle {
    pub handle: __u32,
    #[doc = " Flags.. only applicable for handle->fd"]
    pub flags: __u32,
    #[doc = " Returned dmabuf file descriptor"]
    pub fd: __s32,
}
#[test]
fn bindgen_test_layout_drm_prime_handle() {
    assert_eq!(
        ::std::mem::size_of::<drm_prime_handle>(),
        12usize,
        concat!("Size of: ", stringify!(drm_prime_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_prime_handle>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_prime_handle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_prime_handle>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_prime_handle),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_prime_handle>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_prime_handle),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_prime_handle>())).fd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_prime_handle),
            "::",
            stringify!(fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_syncobj_create {
    pub handle: __u32,
    pub flags: __u32,
}
#[test]
fn bindgen_test_layout_drm_syncobj_create() {
    assert_eq!(
        ::std::mem::size_of::<drm_syncobj_create>(),
        8usize,
        concat!("Size of: ", stringify!(drm_syncobj_create))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_syncobj_create>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_syncobj_create))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_syncobj_create>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_create),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_syncobj_create>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_create),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_syncobj_destroy {
    pub handle: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_drm_syncobj_destroy() {
    assert_eq!(
        ::std::mem::size_of::<drm_syncobj_destroy>(),
        8usize,
        concat!("Size of: ", stringify!(drm_syncobj_destroy))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_syncobj_destroy>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_syncobj_destroy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_syncobj_destroy>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_destroy),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_syncobj_destroy>())).pad as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_destroy),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_syncobj_handle {
    pub handle: __u32,
    pub flags: __u32,
    pub fd: __s32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_drm_syncobj_handle() {
    assert_eq!(
        ::std::mem::size_of::<drm_syncobj_handle>(),
        16usize,
        concat!("Size of: ", stringify!(drm_syncobj_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_syncobj_handle>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_syncobj_handle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_syncobj_handle>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_handle),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_syncobj_handle>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_handle),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_syncobj_handle>())).fd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_handle),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_syncobj_handle>())).pad as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_handle),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_syncobj_transfer {
    pub src_handle: __u32,
    pub dst_handle: __u32,
    pub src_point: __u64,
    pub dst_point: __u64,
    pub flags: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_drm_syncobj_transfer() {
    assert_eq!(
        ::std::mem::size_of::<drm_syncobj_transfer>(),
        32usize,
        concat!("Size of: ", stringify!(drm_syncobj_transfer))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_syncobj_transfer>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_syncobj_transfer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_syncobj_transfer>())).src_handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_transfer),
            "::",
            stringify!(src_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_syncobj_transfer>())).dst_handle as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_transfer),
            "::",
            stringify!(dst_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_syncobj_transfer>())).src_point as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_transfer),
            "::",
            stringify!(src_point)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_syncobj_transfer>())).dst_point as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_transfer),
            "::",
            stringify!(dst_point)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_syncobj_transfer>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_transfer),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_syncobj_transfer>())).pad as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_transfer),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_syncobj_wait {
    pub handles: __u64,
    pub timeout_nsec: __s64,
    pub count_handles: __u32,
    pub flags: __u32,
    pub first_signaled: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_drm_syncobj_wait() {
    assert_eq!(
        ::std::mem::size_of::<drm_syncobj_wait>(),
        32usize,
        concat!("Size of: ", stringify!(drm_syncobj_wait))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_syncobj_wait>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_syncobj_wait))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_syncobj_wait>())).handles as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_wait),
            "::",
            stringify!(handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_syncobj_wait>())).timeout_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_wait),
            "::",
            stringify!(timeout_nsec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_syncobj_wait>())).count_handles as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_wait),
            "::",
            stringify!(count_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_syncobj_wait>())).flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_wait),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_syncobj_wait>())).first_signaled as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_wait),
            "::",
            stringify!(first_signaled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_syncobj_wait>())).pad as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_wait),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_syncobj_timeline_wait {
    pub handles: __u64,
    pub points: __u64,
    pub timeout_nsec: __s64,
    pub count_handles: __u32,
    pub flags: __u32,
    pub first_signaled: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_drm_syncobj_timeline_wait() {
    assert_eq!(
        ::std::mem::size_of::<drm_syncobj_timeline_wait>(),
        40usize,
        concat!("Size of: ", stringify!(drm_syncobj_timeline_wait))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_syncobj_timeline_wait>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_syncobj_timeline_wait))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_syncobj_timeline_wait>())).handles as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_timeline_wait),
            "::",
            stringify!(handles)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_syncobj_timeline_wait>())).points as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_timeline_wait),
            "::",
            stringify!(points)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_syncobj_timeline_wait>())).timeout_nsec as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_timeline_wait),
            "::",
            stringify!(timeout_nsec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_syncobj_timeline_wait>())).count_handles as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_timeline_wait),
            "::",
            stringify!(count_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_syncobj_timeline_wait>())).flags as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_timeline_wait),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_syncobj_timeline_wait>())).first_signaled as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_timeline_wait),
            "::",
            stringify!(first_signaled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_syncobj_timeline_wait>())).pad as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_timeline_wait),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_syncobj_array {
    pub handles: __u64,
    pub count_handles: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_drm_syncobj_array() {
    assert_eq!(
        ::std::mem::size_of::<drm_syncobj_array>(),
        16usize,
        concat!("Size of: ", stringify!(drm_syncobj_array))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_syncobj_array>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_syncobj_array))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_syncobj_array>())).handles as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_array),
            "::",
            stringify!(handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_syncobj_array>())).count_handles as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_array),
            "::",
            stringify!(count_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_syncobj_array>())).pad as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_array),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_syncobj_timeline_array {
    pub handles: __u64,
    pub points: __u64,
    pub count_handles: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_drm_syncobj_timeline_array() {
    assert_eq!(
        ::std::mem::size_of::<drm_syncobj_timeline_array>(),
        24usize,
        concat!("Size of: ", stringify!(drm_syncobj_timeline_array))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_syncobj_timeline_array>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_syncobj_timeline_array))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_syncobj_timeline_array>())).handles as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_timeline_array),
            "::",
            stringify!(handles)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_syncobj_timeline_array>())).points as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_timeline_array),
            "::",
            stringify!(points)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_syncobj_timeline_array>())).count_handles as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_timeline_array),
            "::",
            stringify!(count_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_syncobj_timeline_array>())).pad as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_syncobj_timeline_array),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_crtc_get_sequence {
    pub crtc_id: __u32,
    pub active: __u32,
    pub sequence: __u64,
    pub sequence_ns: __s64,
}
#[test]
fn bindgen_test_layout_drm_crtc_get_sequence() {
    assert_eq!(
        ::std::mem::size_of::<drm_crtc_get_sequence>(),
        24usize,
        concat!("Size of: ", stringify!(drm_crtc_get_sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_crtc_get_sequence>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_crtc_get_sequence))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_crtc_get_sequence>())).crtc_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_crtc_get_sequence),
            "::",
            stringify!(crtc_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_crtc_get_sequence>())).active as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_crtc_get_sequence),
            "::",
            stringify!(active)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_crtc_get_sequence>())).sequence as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_crtc_get_sequence),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_crtc_get_sequence>())).sequence_ns as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_crtc_get_sequence),
            "::",
            stringify!(sequence_ns)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_crtc_queue_sequence {
    pub crtc_id: __u32,
    pub flags: __u32,
    pub sequence: __u64,
    pub user_data: __u64,
}
#[test]
fn bindgen_test_layout_drm_crtc_queue_sequence() {
    assert_eq!(
        ::std::mem::size_of::<drm_crtc_queue_sequence>(),
        24usize,
        concat!("Size of: ", stringify!(drm_crtc_queue_sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_crtc_queue_sequence>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_crtc_queue_sequence))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_crtc_queue_sequence>())).crtc_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_crtc_queue_sequence),
            "::",
            stringify!(crtc_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_crtc_queue_sequence>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_crtc_queue_sequence),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_crtc_queue_sequence>())).sequence as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_crtc_queue_sequence),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_crtc_queue_sequence>())).user_data as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_crtc_queue_sequence),
            "::",
            stringify!(user_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_modeinfo {
    pub clock: __u32,
    pub hdisplay: __u16,
    pub hsync_start: __u16,
    pub hsync_end: __u16,
    pub htotal: __u16,
    pub hskew: __u16,
    pub vdisplay: __u16,
    pub vsync_start: __u16,
    pub vsync_end: __u16,
    pub vtotal: __u16,
    pub vscan: __u16,
    pub vrefresh: __u32,
    pub flags: __u32,
    pub type_: __u32,
    pub name: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_drm_mode_modeinfo() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_modeinfo>(),
        68usize,
        concat!("Size of: ", stringify!(drm_mode_modeinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_modeinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_mode_modeinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_modeinfo>())).clock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_modeinfo),
            "::",
            stringify!(clock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_modeinfo>())).hdisplay as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_modeinfo),
            "::",
            stringify!(hdisplay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_modeinfo>())).hsync_start as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_modeinfo),
            "::",
            stringify!(hsync_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_modeinfo>())).hsync_end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_modeinfo),
            "::",
            stringify!(hsync_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_modeinfo>())).htotal as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_modeinfo),
            "::",
            stringify!(htotal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_modeinfo>())).hskew as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_modeinfo),
            "::",
            stringify!(hskew)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_modeinfo>())).vdisplay as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_modeinfo),
            "::",
            stringify!(vdisplay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_modeinfo>())).vsync_start as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_modeinfo),
            "::",
            stringify!(vsync_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_modeinfo>())).vsync_end as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_modeinfo),
            "::",
            stringify!(vsync_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_modeinfo>())).vtotal as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_modeinfo),
            "::",
            stringify!(vtotal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_modeinfo>())).vscan as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_modeinfo),
            "::",
            stringify!(vscan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_modeinfo>())).vrefresh as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_modeinfo),
            "::",
            stringify!(vrefresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_modeinfo>())).flags as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_modeinfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_modeinfo>())).type_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_modeinfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_modeinfo>())).name as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_modeinfo),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_card_res {
    pub fb_id_ptr: __u64,
    pub crtc_id_ptr: __u64,
    pub connector_id_ptr: __u64,
    pub encoder_id_ptr: __u64,
    pub count_fbs: __u32,
    pub count_crtcs: __u32,
    pub count_connectors: __u32,
    pub count_encoders: __u32,
    pub min_width: __u32,
    pub max_width: __u32,
    pub min_height: __u32,
    pub max_height: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_card_res() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_card_res>(),
        64usize,
        concat!("Size of: ", stringify!(drm_mode_card_res))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_card_res>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_card_res))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_card_res>())).fb_id_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_card_res),
            "::",
            stringify!(fb_id_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_card_res>())).crtc_id_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_card_res),
            "::",
            stringify!(crtc_id_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_card_res>())).connector_id_ptr as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_card_res),
            "::",
            stringify!(connector_id_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_card_res>())).encoder_id_ptr as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_card_res),
            "::",
            stringify!(encoder_id_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_card_res>())).count_fbs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_card_res),
            "::",
            stringify!(count_fbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_card_res>())).count_crtcs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_card_res),
            "::",
            stringify!(count_crtcs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_card_res>())).count_connectors as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_card_res),
            "::",
            stringify!(count_connectors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_card_res>())).count_encoders as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_card_res),
            "::",
            stringify!(count_encoders)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_card_res>())).min_width as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_card_res),
            "::",
            stringify!(min_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_card_res>())).max_width as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_card_res),
            "::",
            stringify!(max_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_card_res>())).min_height as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_card_res),
            "::",
            stringify!(min_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_card_res>())).max_height as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_card_res),
            "::",
            stringify!(max_height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_crtc {
    pub set_connectors_ptr: __u64,
    pub count_connectors: __u32,
    #[doc = "< Id"]
    pub crtc_id: __u32,
    #[doc = "< Id of framebuffer"]
    pub fb_id: __u32,
    #[doc = "< x Position on the framebuffer"]
    pub x: __u32,
    #[doc = "< y Position on the framebuffer"]
    pub y: __u32,
    pub gamma_size: __u32,
    pub mode_valid: __u32,
    pub mode: drm_mode_modeinfo,
}
#[test]
fn bindgen_test_layout_drm_mode_crtc() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_crtc>(),
        104usize,
        concat!("Size of: ", stringify!(drm_mode_crtc))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_crtc>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_crtc))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_crtc>())).set_connectors_ptr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_crtc),
            "::",
            stringify!(set_connectors_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_crtc>())).count_connectors as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_crtc),
            "::",
            stringify!(count_connectors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_crtc>())).crtc_id as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_crtc),
            "::",
            stringify!(crtc_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_crtc>())).fb_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_crtc),
            "::",
            stringify!(fb_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_crtc>())).x as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_crtc),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_crtc>())).y as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_crtc),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_crtc>())).gamma_size as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_crtc),
            "::",
            stringify!(gamma_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_crtc>())).mode_valid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_crtc),
            "::",
            stringify!(mode_valid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_crtc>())).mode as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_crtc),
            "::",
            stringify!(mode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_set_plane {
    pub plane_id: __u32,
    pub crtc_id: __u32,
    pub fb_id: __u32,
    pub flags: __u32,
    pub crtc_x: __s32,
    pub crtc_y: __s32,
    pub crtc_w: __u32,
    pub crtc_h: __u32,
    pub src_x: __u32,
    pub src_y: __u32,
    pub src_h: __u32,
    pub src_w: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_set_plane() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_set_plane>(),
        48usize,
        concat!("Size of: ", stringify!(drm_mode_set_plane))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_set_plane>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_mode_set_plane))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_set_plane>())).plane_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_set_plane),
            "::",
            stringify!(plane_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_set_plane>())).crtc_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_set_plane),
            "::",
            stringify!(crtc_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_set_plane>())).fb_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_set_plane),
            "::",
            stringify!(fb_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_set_plane>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_set_plane),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_set_plane>())).crtc_x as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_set_plane),
            "::",
            stringify!(crtc_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_set_plane>())).crtc_y as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_set_plane),
            "::",
            stringify!(crtc_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_set_plane>())).crtc_w as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_set_plane),
            "::",
            stringify!(crtc_w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_set_plane>())).crtc_h as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_set_plane),
            "::",
            stringify!(crtc_h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_set_plane>())).src_x as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_set_plane),
            "::",
            stringify!(src_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_set_plane>())).src_y as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_set_plane),
            "::",
            stringify!(src_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_set_plane>())).src_h as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_set_plane),
            "::",
            stringify!(src_h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_set_plane>())).src_w as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_set_plane),
            "::",
            stringify!(src_w)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_get_plane {
    pub plane_id: __u32,
    pub crtc_id: __u32,
    pub fb_id: __u32,
    pub possible_crtcs: __u32,
    pub gamma_size: __u32,
    pub count_format_types: __u32,
    pub format_type_ptr: __u64,
}
#[test]
fn bindgen_test_layout_drm_mode_get_plane() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_get_plane>(),
        32usize,
        concat!("Size of: ", stringify!(drm_mode_get_plane))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_get_plane>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_get_plane))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_get_plane>())).plane_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_plane),
            "::",
            stringify!(plane_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_get_plane>())).crtc_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_plane),
            "::",
            stringify!(crtc_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_get_plane>())).fb_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_plane),
            "::",
            stringify!(fb_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_get_plane>())).possible_crtcs as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_plane),
            "::",
            stringify!(possible_crtcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_get_plane>())).gamma_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_plane),
            "::",
            stringify!(gamma_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_get_plane>())).count_format_types as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_plane),
            "::",
            stringify!(count_format_types)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_get_plane>())).format_type_ptr as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_plane),
            "::",
            stringify!(format_type_ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_get_plane_res {
    pub plane_id_ptr: __u64,
    pub count_planes: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_get_plane_res() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_get_plane_res>(),
        16usize,
        concat!("Size of: ", stringify!(drm_mode_get_plane_res))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_get_plane_res>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_get_plane_res))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_get_plane_res>())).plane_id_ptr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_plane_res),
            "::",
            stringify!(plane_id_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_get_plane_res>())).count_planes as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_plane_res),
            "::",
            stringify!(count_planes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_get_encoder {
    pub encoder_id: __u32,
    pub encoder_type: __u32,
    #[doc = "< Id of crtc"]
    pub crtc_id: __u32,
    pub possible_crtcs: __u32,
    pub possible_clones: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_get_encoder() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_get_encoder>(),
        20usize,
        concat!("Size of: ", stringify!(drm_mode_get_encoder))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_get_encoder>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_mode_get_encoder))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_get_encoder>())).encoder_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_encoder),
            "::",
            stringify!(encoder_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_get_encoder>())).encoder_type as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_encoder),
            "::",
            stringify!(encoder_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_get_encoder>())).crtc_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_encoder),
            "::",
            stringify!(crtc_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_get_encoder>())).possible_crtcs as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_encoder),
            "::",
            stringify!(possible_crtcs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_get_encoder>())).possible_clones as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_encoder),
            "::",
            stringify!(possible_clones)
        )
    );
}
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_Automatic: drm_mode_subconnector = 0;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_Unknown: drm_mode_subconnector = 0;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_DVID: drm_mode_subconnector = 3;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_DVIA: drm_mode_subconnector = 4;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_Composite: drm_mode_subconnector = 5;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_SVIDEO: drm_mode_subconnector = 6;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_Component: drm_mode_subconnector = 8;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_SCART: drm_mode_subconnector = 9;
pub type drm_mode_subconnector = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_get_connector {
    pub encoders_ptr: __u64,
    pub modes_ptr: __u64,
    pub props_ptr: __u64,
    pub prop_values_ptr: __u64,
    pub count_modes: __u32,
    pub count_props: __u32,
    pub count_encoders: __u32,
    #[doc = "< Current Encoder"]
    pub encoder_id: __u32,
    #[doc = "< Id"]
    pub connector_id: __u32,
    pub connector_type: __u32,
    pub connector_type_id: __u32,
    pub connection: __u32,
    #[doc = "< width in millimeters"]
    pub mm_width: __u32,
    #[doc = "< height in millimeters"]
    pub mm_height: __u32,
    pub subpixel: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_get_connector() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_get_connector>(),
        80usize,
        concat!("Size of: ", stringify!(drm_mode_get_connector))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_get_connector>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_get_connector))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_get_connector>())).encoders_ptr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(encoders_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_get_connector>())).modes_ptr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(modes_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_get_connector>())).props_ptr as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(props_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_get_connector>())).prop_values_ptr as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(prop_values_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_get_connector>())).count_modes as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(count_modes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_get_connector>())).count_props as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(count_props)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_get_connector>())).count_encoders as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(count_encoders)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_get_connector>())).encoder_id as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(encoder_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_get_connector>())).connector_id as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(connector_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_get_connector>())).connector_type as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(connector_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_get_connector>())).connector_type_id as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(connector_type_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_get_connector>())).connection as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(connection)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_get_connector>())).mm_width as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(mm_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_get_connector>())).mm_height as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(mm_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_get_connector>())).subpixel as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(subpixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_get_connector>())).pad as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_property_enum {
    pub value: __u64,
    pub name: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_drm_mode_property_enum() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_property_enum>(),
        40usize,
        concat!("Size of: ", stringify!(drm_mode_property_enum))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_property_enum>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_property_enum))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_property_enum>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_property_enum),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_property_enum>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_property_enum),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_get_property {
    pub values_ptr: __u64,
    pub enum_blob_ptr: __u64,
    pub prop_id: __u32,
    pub flags: __u32,
    pub name: [::std::os::raw::c_char; 32usize],
    pub count_values: __u32,
    pub count_enum_blobs: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_get_property() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_get_property>(),
        64usize,
        concat!("Size of: ", stringify!(drm_mode_get_property))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_get_property>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_get_property))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_get_property>())).values_ptr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_property),
            "::",
            stringify!(values_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_get_property>())).enum_blob_ptr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_property),
            "::",
            stringify!(enum_blob_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_get_property>())).prop_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_property),
            "::",
            stringify!(prop_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_get_property>())).flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_property),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_get_property>())).name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_property),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_get_property>())).count_values as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_property),
            "::",
            stringify!(count_values)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_get_property>())).count_enum_blobs as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_property),
            "::",
            stringify!(count_enum_blobs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_connector_set_property {
    pub value: __u64,
    pub prop_id: __u32,
    pub connector_id: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_connector_set_property() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_connector_set_property>(),
        16usize,
        concat!("Size of: ", stringify!(drm_mode_connector_set_property))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_connector_set_property>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_connector_set_property))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_connector_set_property>())).value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_connector_set_property),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_connector_set_property>())).prop_id as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_connector_set_property),
            "::",
            stringify!(prop_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_connector_set_property>())).connector_id as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_connector_set_property),
            "::",
            stringify!(connector_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_obj_get_properties {
    pub props_ptr: __u64,
    pub prop_values_ptr: __u64,
    pub count_props: __u32,
    pub obj_id: __u32,
    pub obj_type: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_obj_get_properties() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_obj_get_properties>(),
        32usize,
        concat!("Size of: ", stringify!(drm_mode_obj_get_properties))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_obj_get_properties>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_obj_get_properties))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_obj_get_properties>())).props_ptr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_obj_get_properties),
            "::",
            stringify!(props_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_obj_get_properties>())).prop_values_ptr as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_obj_get_properties),
            "::",
            stringify!(prop_values_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_obj_get_properties>())).count_props as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_obj_get_properties),
            "::",
            stringify!(count_props)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_obj_get_properties>())).obj_id as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_obj_get_properties),
            "::",
            stringify!(obj_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_obj_get_properties>())).obj_type as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_obj_get_properties),
            "::",
            stringify!(obj_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_obj_set_property {
    pub value: __u64,
    pub prop_id: __u32,
    pub obj_id: __u32,
    pub obj_type: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_obj_set_property() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_obj_set_property>(),
        24usize,
        concat!("Size of: ", stringify!(drm_mode_obj_set_property))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_obj_set_property>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_obj_set_property))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_obj_set_property>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_obj_set_property),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_obj_set_property>())).prop_id as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_obj_set_property),
            "::",
            stringify!(prop_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_obj_set_property>())).obj_id as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_obj_set_property),
            "::",
            stringify!(obj_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_obj_set_property>())).obj_type as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_obj_set_property),
            "::",
            stringify!(obj_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_get_blob {
    pub blob_id: __u32,
    pub length: __u32,
    pub data: __u64,
}
#[test]
fn bindgen_test_layout_drm_mode_get_blob() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_get_blob>(),
        16usize,
        concat!("Size of: ", stringify!(drm_mode_get_blob))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_get_blob>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_get_blob))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_get_blob>())).blob_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_blob),
            "::",
            stringify!(blob_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_get_blob>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_blob),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_get_blob>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_blob),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_fb_cmd {
    pub fb_id: __u32,
    pub width: __u32,
    pub height: __u32,
    pub pitch: __u32,
    pub bpp: __u32,
    pub depth: __u32,
    pub handle: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_fb_cmd() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_fb_cmd>(),
        28usize,
        concat!("Size of: ", stringify!(drm_mode_fb_cmd))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_fb_cmd>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_mode_fb_cmd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_fb_cmd>())).fb_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_fb_cmd),
            "::",
            stringify!(fb_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_fb_cmd>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_fb_cmd),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_fb_cmd>())).height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_fb_cmd),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_fb_cmd>())).pitch as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_fb_cmd),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_fb_cmd>())).bpp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_fb_cmd),
            "::",
            stringify!(bpp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_fb_cmd>())).depth as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_fb_cmd),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_fb_cmd>())).handle as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_fb_cmd),
            "::",
            stringify!(handle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_fb_cmd2 {
    pub fb_id: __u32,
    pub width: __u32,
    pub height: __u32,
    pub pixel_format: __u32,
    pub flags: __u32,
    pub handles: [__u32; 4usize],
    pub pitches: [__u32; 4usize],
    pub offsets: [__u32; 4usize],
    pub modifier: [__u64; 4usize],
}
#[test]
fn bindgen_test_layout_drm_mode_fb_cmd2() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_fb_cmd2>(),
        104usize,
        concat!("Size of: ", stringify!(drm_mode_fb_cmd2))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_fb_cmd2>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_fb_cmd2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_fb_cmd2>())).fb_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_fb_cmd2),
            "::",
            stringify!(fb_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_fb_cmd2>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_fb_cmd2),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_fb_cmd2>())).height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_fb_cmd2),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_fb_cmd2>())).pixel_format as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_fb_cmd2),
            "::",
            stringify!(pixel_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_fb_cmd2>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_fb_cmd2),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_fb_cmd2>())).handles as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_fb_cmd2),
            "::",
            stringify!(handles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_fb_cmd2>())).pitches as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_fb_cmd2),
            "::",
            stringify!(pitches)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_fb_cmd2>())).offsets as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_fb_cmd2),
            "::",
            stringify!(offsets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_fb_cmd2>())).modifier as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_fb_cmd2),
            "::",
            stringify!(modifier)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_fb_dirty_cmd {
    pub fb_id: __u32,
    pub flags: __u32,
    pub color: __u32,
    pub num_clips: __u32,
    pub clips_ptr: __u64,
}
#[test]
fn bindgen_test_layout_drm_mode_fb_dirty_cmd() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_fb_dirty_cmd>(),
        24usize,
        concat!("Size of: ", stringify!(drm_mode_fb_dirty_cmd))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_fb_dirty_cmd>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_fb_dirty_cmd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_fb_dirty_cmd>())).fb_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_fb_dirty_cmd),
            "::",
            stringify!(fb_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_fb_dirty_cmd>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_fb_dirty_cmd),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_fb_dirty_cmd>())).color as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_fb_dirty_cmd),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_fb_dirty_cmd>())).num_clips as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_fb_dirty_cmd),
            "::",
            stringify!(num_clips)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_fb_dirty_cmd>())).clips_ptr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_fb_dirty_cmd),
            "::",
            stringify!(clips_ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_mode_cmd {
    pub connector_id: __u32,
    pub mode: drm_mode_modeinfo,
}
#[test]
fn bindgen_test_layout_drm_mode_mode_cmd() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_mode_cmd>(),
        72usize,
        concat!("Size of: ", stringify!(drm_mode_mode_cmd))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_mode_cmd>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_mode_mode_cmd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_mode_cmd>())).connector_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_mode_cmd),
            "::",
            stringify!(connector_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_mode_cmd>())).mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_mode_cmd),
            "::",
            stringify!(mode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_cursor {
    pub flags: __u32,
    pub crtc_id: __u32,
    pub x: __s32,
    pub y: __s32,
    pub width: __u32,
    pub height: __u32,
    pub handle: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_cursor() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_cursor>(),
        28usize,
        concat!("Size of: ", stringify!(drm_mode_cursor))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_cursor>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_mode_cursor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_cursor>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_cursor),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_cursor>())).crtc_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_cursor),
            "::",
            stringify!(crtc_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_cursor>())).x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_cursor),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_cursor>())).y as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_cursor),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_cursor>())).width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_cursor),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_cursor>())).height as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_cursor),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_cursor>())).handle as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_cursor),
            "::",
            stringify!(handle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_cursor2 {
    pub flags: __u32,
    pub crtc_id: __u32,
    pub x: __s32,
    pub y: __s32,
    pub width: __u32,
    pub height: __u32,
    pub handle: __u32,
    pub hot_x: __s32,
    pub hot_y: __s32,
}
#[test]
fn bindgen_test_layout_drm_mode_cursor2() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_cursor2>(),
        36usize,
        concat!("Size of: ", stringify!(drm_mode_cursor2))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_cursor2>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_mode_cursor2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_cursor2>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_cursor2),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_cursor2>())).crtc_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_cursor2),
            "::",
            stringify!(crtc_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_cursor2>())).x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_cursor2),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_cursor2>())).y as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_cursor2),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_cursor2>())).width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_cursor2),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_cursor2>())).height as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_cursor2),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_cursor2>())).handle as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_cursor2),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_cursor2>())).hot_x as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_cursor2),
            "::",
            stringify!(hot_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_cursor2>())).hot_y as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_cursor2),
            "::",
            stringify!(hot_y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_crtc_lut {
    pub crtc_id: __u32,
    pub gamma_size: __u32,
    pub red: __u64,
    pub green: __u64,
    pub blue: __u64,
}
#[test]
fn bindgen_test_layout_drm_mode_crtc_lut() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_crtc_lut>(),
        32usize,
        concat!("Size of: ", stringify!(drm_mode_crtc_lut))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_crtc_lut>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_crtc_lut))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_crtc_lut>())).crtc_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_crtc_lut),
            "::",
            stringify!(crtc_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_crtc_lut>())).gamma_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_crtc_lut),
            "::",
            stringify!(gamma_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_crtc_lut>())).red as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_crtc_lut),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_crtc_lut>())).green as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_crtc_lut),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_crtc_lut>())).blue as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_crtc_lut),
            "::",
            stringify!(blue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_color_ctm {
    pub matrix: [__u64; 9usize],
}
#[test]
fn bindgen_test_layout_drm_color_ctm() {
    assert_eq!(
        ::std::mem::size_of::<drm_color_ctm>(),
        72usize,
        concat!("Size of: ", stringify!(drm_color_ctm))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_color_ctm>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_color_ctm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_color_ctm>())).matrix as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_color_ctm),
            "::",
            stringify!(matrix)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_color_lut {
    pub red: __u16,
    pub green: __u16,
    pub blue: __u16,
    pub reserved: __u16,
}
#[test]
fn bindgen_test_layout_drm_color_lut() {
    assert_eq!(
        ::std::mem::size_of::<drm_color_lut>(),
        8usize,
        concat!("Size of: ", stringify!(drm_color_lut))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_color_lut>(),
        2usize,
        concat!("Alignment of ", stringify!(drm_color_lut))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_color_lut>())).red as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_color_lut),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_color_lut>())).green as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_color_lut),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_color_lut>())).blue as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_color_lut),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_color_lut>())).reserved as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_color_lut),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_crtc_page_flip {
    pub crtc_id: __u32,
    pub fb_id: __u32,
    pub flags: __u32,
    pub reserved: __u32,
    pub user_data: __u64,
}
#[test]
fn bindgen_test_layout_drm_mode_crtc_page_flip() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_crtc_page_flip>(),
        24usize,
        concat!("Size of: ", stringify!(drm_mode_crtc_page_flip))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_crtc_page_flip>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_crtc_page_flip))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_crtc_page_flip>())).crtc_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_crtc_page_flip),
            "::",
            stringify!(crtc_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_crtc_page_flip>())).fb_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_crtc_page_flip),
            "::",
            stringify!(fb_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_crtc_page_flip>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_crtc_page_flip),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_crtc_page_flip>())).reserved as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_crtc_page_flip),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_crtc_page_flip>())).user_data as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_crtc_page_flip),
            "::",
            stringify!(user_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_crtc_page_flip_target {
    pub crtc_id: __u32,
    pub fb_id: __u32,
    pub flags: __u32,
    pub sequence: __u32,
    pub user_data: __u64,
}
#[test]
fn bindgen_test_layout_drm_mode_crtc_page_flip_target() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_crtc_page_flip_target>(),
        24usize,
        concat!("Size of: ", stringify!(drm_mode_crtc_page_flip_target))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_crtc_page_flip_target>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_crtc_page_flip_target))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_crtc_page_flip_target>())).crtc_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_crtc_page_flip_target),
            "::",
            stringify!(crtc_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_crtc_page_flip_target>())).fb_id as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_crtc_page_flip_target),
            "::",
            stringify!(fb_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_crtc_page_flip_target>())).flags as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_crtc_page_flip_target),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_crtc_page_flip_target>())).sequence as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_crtc_page_flip_target),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_crtc_page_flip_target>())).user_data as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_crtc_page_flip_target),
            "::",
            stringify!(user_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_create_dumb {
    pub height: __u32,
    pub width: __u32,
    pub bpp: __u32,
    pub flags: __u32,
    pub handle: __u32,
    pub pitch: __u32,
    pub size: __u64,
}
#[test]
fn bindgen_test_layout_drm_mode_create_dumb() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_create_dumb>(),
        32usize,
        concat!("Size of: ", stringify!(drm_mode_create_dumb))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_create_dumb>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_create_dumb))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_create_dumb>())).height as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_create_dumb),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_create_dumb>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_create_dumb),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_create_dumb>())).bpp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_create_dumb),
            "::",
            stringify!(bpp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_create_dumb>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_create_dumb),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_create_dumb>())).handle as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_create_dumb),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_create_dumb>())).pitch as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_create_dumb),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_create_dumb>())).size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_create_dumb),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_map_dumb {
    #[doc = " Handle for the object being mapped."]
    pub handle: __u32,
    pub pad: __u32,
    #[doc = " Fake offset to use for subsequent mmap call"]
    #[doc = ""]
    #[doc = " This is a fixed-size type for 32/64 compatibility."]
    pub offset: __u64,
}
#[test]
fn bindgen_test_layout_drm_mode_map_dumb() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_map_dumb>(),
        16usize,
        concat!("Size of: ", stringify!(drm_mode_map_dumb))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_map_dumb>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_map_dumb))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_map_dumb>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_map_dumb),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_map_dumb>())).pad as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_map_dumb),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_map_dumb>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_map_dumb),
            "::",
            stringify!(offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_destroy_dumb {
    pub handle: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_destroy_dumb() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_destroy_dumb>(),
        4usize,
        concat!("Size of: ", stringify!(drm_mode_destroy_dumb))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_destroy_dumb>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_mode_destroy_dumb))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_destroy_dumb>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_destroy_dumb),
            "::",
            stringify!(handle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_atomic {
    pub flags: __u32,
    pub count_objs: __u32,
    pub objs_ptr: __u64,
    pub count_props_ptr: __u64,
    pub props_ptr: __u64,
    pub prop_values_ptr: __u64,
    pub reserved: __u64,
    pub user_data: __u64,
}
#[test]
fn bindgen_test_layout_drm_mode_atomic() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_atomic>(),
        56usize,
        concat!("Size of: ", stringify!(drm_mode_atomic))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_atomic>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_atomic))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_atomic>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_atomic),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_atomic>())).count_objs as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_atomic),
            "::",
            stringify!(count_objs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_atomic>())).objs_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_atomic),
            "::",
            stringify!(objs_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_atomic>())).count_props_ptr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_atomic),
            "::",
            stringify!(count_props_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_atomic>())).props_ptr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_atomic),
            "::",
            stringify!(props_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_atomic>())).prop_values_ptr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_atomic),
            "::",
            stringify!(prop_values_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_atomic>())).reserved as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_atomic),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_atomic>())).user_data as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_atomic),
            "::",
            stringify!(user_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_format_modifier_blob {
    pub version: __u32,
    pub flags: __u32,
    pub count_formats: __u32,
    pub formats_offset: __u32,
    pub count_modifiers: __u32,
    pub modifiers_offset: __u32,
}
#[test]
fn bindgen_test_layout_drm_format_modifier_blob() {
    assert_eq!(
        ::std::mem::size_of::<drm_format_modifier_blob>(),
        24usize,
        concat!("Size of: ", stringify!(drm_format_modifier_blob))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_format_modifier_blob>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_format_modifier_blob))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_format_modifier_blob>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_format_modifier_blob),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_format_modifier_blob>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_format_modifier_blob),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_format_modifier_blob>())).count_formats as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_format_modifier_blob),
            "::",
            stringify!(count_formats)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_format_modifier_blob>())).formats_offset as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_format_modifier_blob),
            "::",
            stringify!(formats_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_format_modifier_blob>())).count_modifiers as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_format_modifier_blob),
            "::",
            stringify!(count_modifiers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_format_modifier_blob>())).modifiers_offset as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_format_modifier_blob),
            "::",
            stringify!(modifiers_offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_format_modifier {
    pub formats: __u64,
    pub offset: __u32,
    pub pad: __u32,
    pub modifier: __u64,
}
#[test]
fn bindgen_test_layout_drm_format_modifier() {
    assert_eq!(
        ::std::mem::size_of::<drm_format_modifier>(),
        24usize,
        concat!("Size of: ", stringify!(drm_format_modifier))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_format_modifier>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_format_modifier))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_format_modifier>())).formats as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_format_modifier),
            "::",
            stringify!(formats)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_format_modifier>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_format_modifier),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_format_modifier>())).pad as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_format_modifier),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_format_modifier>())).modifier as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_format_modifier),
            "::",
            stringify!(modifier)
        )
    );
}
#[doc = " Create a new 'blob' data property, copying length bytes from data pointer,"]
#[doc = " and returning new blob ID."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_create_blob {
    #[doc = " Pointer to data to copy."]
    pub data: __u64,
    #[doc = " Length of data to copy."]
    pub length: __u32,
    #[doc = " Return: new property ID."]
    pub blob_id: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_create_blob() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_create_blob>(),
        16usize,
        concat!("Size of: ", stringify!(drm_mode_create_blob))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_create_blob>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_create_blob))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_create_blob>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_create_blob),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_create_blob>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_create_blob),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_create_blob>())).blob_id as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_create_blob),
            "::",
            stringify!(blob_id)
        )
    );
}
#[doc = " Destroy a user-created blob property."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_destroy_blob {
    pub blob_id: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_destroy_blob() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_destroy_blob>(),
        4usize,
        concat!("Size of: ", stringify!(drm_mode_destroy_blob))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_destroy_blob>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_mode_destroy_blob))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_destroy_blob>())).blob_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_destroy_blob),
            "::",
            stringify!(blob_id)
        )
    );
}
#[doc = " Lease mode resources, creating another drm_master."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_create_lease {
    #[doc = " Pointer to array of object ids (__u32)"]
    pub object_ids: __u64,
    #[doc = " Number of object ids"]
    pub object_count: __u32,
    #[doc = " flags for new FD (O_CLOEXEC, etc)"]
    pub flags: __u32,
    #[doc = " Return: unique identifier for lessee."]
    pub lessee_id: __u32,
    #[doc = " Return: file descriptor to new drm_master file"]
    pub fd: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_create_lease() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_create_lease>(),
        24usize,
        concat!("Size of: ", stringify!(drm_mode_create_lease))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_create_lease>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_create_lease))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_create_lease>())).object_ids as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_create_lease),
            "::",
            stringify!(object_ids)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_create_lease>())).object_count as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_create_lease),
            "::",
            stringify!(object_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_create_lease>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_create_lease),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_create_lease>())).lessee_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_create_lease),
            "::",
            stringify!(lessee_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_create_lease>())).fd as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_create_lease),
            "::",
            stringify!(fd)
        )
    );
}
#[doc = " List lesses from a drm_master"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_list_lessees {
    #[doc = " Number of lessees."]
    #[doc = " On input, provides length of the array."]
    #[doc = " On output, provides total number. No"]
    #[doc = " more than the input number will be written"]
    #[doc = " back, so two calls can be used to get"]
    #[doc = " the size and then the data."]
    pub count_lessees: __u32,
    pub pad: __u32,
    #[doc = " Pointer to lessees."]
    #[doc = " pointer to __u64 array of lessee ids"]
    pub lessees_ptr: __u64,
}
#[test]
fn bindgen_test_layout_drm_mode_list_lessees() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_list_lessees>(),
        16usize,
        concat!("Size of: ", stringify!(drm_mode_list_lessees))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_list_lessees>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_list_lessees))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_list_lessees>())).count_lessees as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_list_lessees),
            "::",
            stringify!(count_lessees)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_list_lessees>())).pad as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_list_lessees),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_list_lessees>())).lessees_ptr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_list_lessees),
            "::",
            stringify!(lessees_ptr)
        )
    );
}
#[doc = " Get leased objects"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_get_lease {
    #[doc = " Number of leased objects."]
    #[doc = " On input, provides length of the array."]
    #[doc = " On output, provides total number. No"]
    #[doc = " more than the input number will be written"]
    #[doc = " back, so two calls can be used to get"]
    #[doc = " the size and then the data."]
    pub count_objects: __u32,
    pub pad: __u32,
    #[doc = " Pointer to objects."]
    #[doc = " pointer to __u32 array of object ids"]
    pub objects_ptr: __u64,
}
#[test]
fn bindgen_test_layout_drm_mode_get_lease() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_get_lease>(),
        16usize,
        concat!("Size of: ", stringify!(drm_mode_get_lease))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_get_lease>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_get_lease))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_mode_get_lease>())).count_objects as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_lease),
            "::",
            stringify!(count_objects)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_get_lease>())).pad as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_lease),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_get_lease>())).objects_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_get_lease),
            "::",
            stringify!(objects_ptr)
        )
    );
}
#[doc = " Revoke lease"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_revoke_lease {
    #[doc = " Unique ID of lessee"]
    pub lessee_id: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_revoke_lease() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_revoke_lease>(),
        4usize,
        concat!("Size of: ", stringify!(drm_mode_revoke_lease))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_revoke_lease>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_mode_revoke_lease))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_revoke_lease>())).lessee_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_revoke_lease),
            "::",
            stringify!(lessee_id)
        )
    );
}
#[doc = " struct drm_mode_rect - Two dimensional rectangle."]
#[doc = " @x1: Horizontal starting coordinate (inclusive)."]
#[doc = " @y1: Vertical starting coordinate (inclusive)."]
#[doc = " @x2: Horizontal ending coordinate (exclusive)."]
#[doc = " @y2: Vertical ending coordinate (exclusive)."]
#[doc = ""]
#[doc = " With drm subsystem using struct drm_rect to manage rectangular area this"]
#[doc = " export it to user-space."]
#[doc = ""]
#[doc = " Currently used by drm_mode_atomic blob property FB_DAMAGE_CLIPS."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_mode_rect {
    pub x1: __s32,
    pub y1: __s32,
    pub x2: __s32,
    pub y2: __s32,
}
#[test]
fn bindgen_test_layout_drm_mode_rect() {
    assert_eq!(
        ::std::mem::size_of::<drm_mode_rect>(),
        16usize,
        concat!("Size of: ", stringify!(drm_mode_rect))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_mode_rect>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_mode_rect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_rect>())).x1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_rect),
            "::",
            stringify!(x1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_rect>())).y1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_rect),
            "::",
            stringify!(y1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_rect>())).x2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_rect),
            "::",
            stringify!(x2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_mode_rect>())).y2 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_mode_rect),
            "::",
            stringify!(y2)
        )
    );
}
#[doc = " Header for events written back to userspace on the drm fd.  The"]
#[doc = " type defines the type of event, the length specifies the total"]
#[doc = " length of the event (including the header), and user_data is"]
#[doc = " typically a 64 bit value passed with the ioctl that triggered the"]
#[doc = " event.  A read on the drm fd will always only return complete"]
#[doc = " events, that is, if for example the read buffer is 100 bytes, and"]
#[doc = " there are two 64 byte events pending, only one will be returned."]
#[doc = ""]
#[doc = " Event types 0 - 0x7fffffff are generic drm events, 0x80000000 and"]
#[doc = " up are chipset specific."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_event {
    pub type_: __u32,
    pub length: __u32,
}
#[test]
fn bindgen_test_layout_drm_event() {
    assert_eq!(
        ::std::mem::size_of::<drm_event>(),
        8usize,
        concat!("Size of: ", stringify!(drm_event))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_event>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_event>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_event),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_event>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_event),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_event_vblank {
    pub base: drm_event,
    pub user_data: __u64,
    pub tv_sec: __u32,
    pub tv_usec: __u32,
    pub sequence: __u32,
    pub crtc_id: __u32,
}
#[test]
fn bindgen_test_layout_drm_event_vblank() {
    assert_eq!(
        ::std::mem::size_of::<drm_event_vblank>(),
        32usize,
        concat!("Size of: ", stringify!(drm_event_vblank))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_event_vblank>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_event_vblank))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_event_vblank>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_event_vblank),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_event_vblank>())).user_data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_event_vblank),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_event_vblank>())).tv_sec as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_event_vblank),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_event_vblank>())).tv_usec as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_event_vblank),
            "::",
            stringify!(tv_usec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_event_vblank>())).sequence as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_event_vblank),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_event_vblank>())).crtc_id as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_event_vblank),
            "::",
            stringify!(crtc_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct drm_event_crtc_sequence {
    pub base: drm_event,
    pub user_data: __u64,
    pub time_ns: __s64,
    pub sequence: __u64,
}
#[test]
fn bindgen_test_layout_drm_event_crtc_sequence() {
    assert_eq!(
        ::std::mem::size_of::<drm_event_crtc_sequence>(),
        32usize,
        concat!("Size of: ", stringify!(drm_event_crtc_sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<drm_event_crtc_sequence>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_event_crtc_sequence))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_event_crtc_sequence>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_event_crtc_sequence),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_event_crtc_sequence>())).user_data as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_event_crtc_sequence),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drm_event_crtc_sequence>())).time_ns as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_event_crtc_sequence),
            "::",
            stringify!(time_ns)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drm_event_crtc_sequence>())).sequence as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(drm_event_crtc_sequence),
            "::",
            stringify!(sequence)
        )
    );
}
pub type drm_clip_rect_t = drm_clip_rect;
pub type drm_drawable_info_t = drm_drawable_info;
pub type drm_tex_region_t = drm_tex_region;
pub type drm_hw_lock_t = drm_hw_lock;
pub type drm_version_t = drm_version;
pub type drm_unique_t = drm_unique;
pub type drm_list_t = drm_list;
pub type drm_block_t = drm_block;
pub type drm_control_t = drm_control;
pub use self::drm_map_flags as drm_map_flags_t;
pub use self::drm_map_type as drm_map_type_t;
pub type drm_ctx_priv_map_t = drm_ctx_priv_map;
pub type drm_map_t = drm_map;
pub type drm_client_t = drm_client;
pub use self::drm_stat_type as drm_stat_type_t;
pub type drm_stats_t = drm_stats;
pub use self::drm_lock_flags as drm_lock_flags_t;
pub type drm_lock_t = drm_lock;
pub use self::drm_dma_flags as drm_dma_flags_t;
pub type drm_buf_desc_t = drm_buf_desc;
pub type drm_buf_info_t = drm_buf_info;
pub type drm_buf_free_t = drm_buf_free;
pub type drm_buf_pub_t = drm_buf_pub;
pub type drm_buf_map_t = drm_buf_map;
pub type drm_dma_t = drm_dma;
pub type drm_wait_vblank_t = drm_wait_vblank;
pub type drm_agp_mode_t = drm_agp_mode;
pub use self::drm_ctx_flags as drm_ctx_flags_t;
pub type drm_ctx_t = drm_ctx;
pub type drm_ctx_res_t = drm_ctx_res;
pub type drm_draw_t = drm_draw;
pub type drm_update_draw_t = drm_update_draw;
pub type drm_auth_t = drm_auth;
pub type drm_irq_busid_t = drm_irq_busid;
pub use self::drm_vblank_seq_type as drm_vblank_seq_type_t;
pub type drm_agp_buffer_t = drm_agp_buffer;
pub type drm_agp_binding_t = drm_agp_binding;
pub type drm_agp_info_t = drm_agp_info;
pub type drm_scatter_gather_t = drm_scatter_gather;
pub type drm_set_version_t = drm_set_version;
