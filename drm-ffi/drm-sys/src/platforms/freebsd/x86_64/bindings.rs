/* automatically generated by rust-bindgen */

pub const IOCPARM_SHIFT: libc::c_uint = 13;
pub const IOCPARM_MASK: libc::c_uint = 8191;
pub const IOCPARM_MAX: libc::c_uint = 8192;
pub const IOC_VOID: libc::c_uint = 536870912;
pub const IOC_OUT: libc::c_uint = 1073741824;
pub const IOC_IN: libc::c_uint = 2147483648;
pub const IOC_INOUT: libc::c_uint = 3221225472;
pub const IOC_DIRMASK: libc::c_uint = 3758096384;
pub const __GNUCLIKE_ASM: libc::c_uint = 3;
pub const __GNUCLIKE___TYPEOF: libc::c_uint = 1;
pub const __GNUCLIKE___OFFSETOF: libc::c_uint = 1;
pub const __GNUCLIKE___SECTION: libc::c_uint = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: libc::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: libc::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: libc::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: libc::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: libc::c_uint = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: libc::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: libc::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: libc::c_uint = 1;
pub const __CC_SUPPORTS_INLINE: libc::c_uint = 1;
pub const __CC_SUPPORTS___INLINE: libc::c_uint = 1;
pub const __CC_SUPPORTS___INLINE__: libc::c_uint = 1;
pub const __CC_SUPPORTS___FUNC__: libc::c_uint = 1;
pub const __CC_SUPPORTS_WARNING: libc::c_uint = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: libc::c_uint = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: libc::c_uint = 1;
pub const __POSIX_VISIBLE: libc::c_uint = 200809;
pub const __XSI_VISIBLE: libc::c_uint = 700;
pub const __BSD_VISIBLE: libc::c_uint = 1;
pub const __ISO_C_VISIBLE: libc::c_uint = 2011;
pub const __EXT1_VISIBLE: libc::c_uint = 1;
pub const __CHAR_BIT: libc::c_uint = 8;
pub const __SCHAR_MAX: libc::c_uint = 127;
pub const __SCHAR_MIN: libc::c_int = -128;
pub const __UCHAR_MAX: libc::c_uint = 255;
pub const __USHRT_MAX: libc::c_uint = 65535;
pub const __SHRT_MAX: libc::c_uint = 32767;
pub const __SHRT_MIN: libc::c_int = -32768;
pub const __UINT_MAX: libc::c_uint = 4294967295;
pub const __INT_MAX: libc::c_uint = 2147483647;
pub const __INT_MIN: libc::c_int = -2147483648;
pub const __ULONG_MAX: libc::c_int = -1;
pub const __LONG_MAX: libc::c_ulonglong = 9223372036854775807;
pub const __LONG_MIN: libc::c_longlong = -9223372036854775808;
pub const __ULLONG_MAX: libc::c_int = -1;
pub const __LLONG_MAX: libc::c_ulonglong = 9223372036854775807;
pub const __LLONG_MIN: libc::c_longlong = -9223372036854775808;
pub const __SSIZE_MAX: libc::c_ulonglong = 9223372036854775807;
pub const __SIZE_T_MAX: libc::c_int = -1;
pub const __OFF_MAX: libc::c_ulonglong = 9223372036854775807;
pub const __OFF_MIN: libc::c_longlong = -9223372036854775808;
pub const __UQUAD_MAX: libc::c_int = -1;
pub const __QUAD_MAX: libc::c_ulonglong = 9223372036854775807;
pub const __QUAD_MIN: libc::c_longlong = -9223372036854775808;
pub const __LONG_BIT: libc::c_uint = 64;
pub const __WORD_BIT: libc::c_uint = 32;
pub const __MINSIGSTKSZ: libc::c_uint = 2048;
pub const __WCHAR_MIN: libc::c_int = -2147483648;
pub const __WCHAR_MAX: libc::c_uint = 2147483647;
pub const _QUAD_HIGHWORD: libc::c_uint = 1;
pub const _QUAD_LOWWORD: libc::c_uint = 0;
pub const _LITTLE_ENDIAN: libc::c_uint = 1234;
pub const _BIG_ENDIAN: libc::c_uint = 4321;
pub const _PDP_ENDIAN: libc::c_uint = 3412;
pub const _BYTE_ORDER: libc::c_uint = 1234;
pub const LITTLE_ENDIAN: libc::c_uint = 1234;
pub const BIG_ENDIAN: libc::c_uint = 4321;
pub const PDP_ENDIAN: libc::c_uint = 3412;
pub const BYTE_ORDER: libc::c_uint = 1234;
pub const _SIG_WORDS: libc::c_uint = 4;
pub const _SIG_MAXSIG: libc::c_uint = 128;
pub const FD_SETSIZE: libc::c_uint = 1024;
pub const DRM_NAME: &'static [u8; 4usize] = b"drm\0";
pub const DRM_MIN_ORDER: libc::c_uint = 5;
pub const DRM_MAX_ORDER: libc::c_uint = 22;
pub const DRM_RAM_PERCENT: libc::c_uint = 10;
pub const _DRM_LOCK_HELD: libc::c_uint = 2147483648;
pub const _DRM_LOCK_CONT: libc::c_uint = 1073741824;
pub const _DRM_VBLANK_HIGH_CRTC_SHIFT: libc::c_uint = 1;
pub const _DRM_PRE_MODESET: libc::c_uint = 1;
pub const _DRM_POST_MODESET: libc::c_uint = 2;
pub const DRM_CAP_DUMB_BUFFER: libc::c_uint = 1;
pub const DRM_CAP_VBLANK_HIGH_CRTC: libc::c_uint = 2;
pub const DRM_CAP_DUMB_PREFERRED_DEPTH: libc::c_uint = 3;
pub const DRM_CAP_DUMB_PREFER_SHADOW: libc::c_uint = 4;
pub const DRM_CAP_PRIME: libc::c_uint = 5;
pub const DRM_PRIME_CAP_IMPORT: libc::c_uint = 1;
pub const DRM_PRIME_CAP_EXPORT: libc::c_uint = 2;
pub const DRM_CAP_TIMESTAMP_MONOTONIC: libc::c_uint = 6;
pub const DRM_CAP_ASYNC_PAGE_FLIP: libc::c_uint = 7;
pub const DRM_CAP_CURSOR_WIDTH: libc::c_uint = 8;
pub const DRM_CAP_CURSOR_HEIGHT: libc::c_uint = 9;
pub const DRM_CAP_ADDFB2_MODIFIERS: libc::c_uint = 16;
pub const DRM_CAP_PAGE_FLIP_TARGET: libc::c_uint = 17;
pub const DRM_CAP_CRTC_IN_VBLANK_EVENT: libc::c_uint = 18;
pub const DRM_CAP_SYNCOBJ: libc::c_uint = 19;
pub const DRM_CLIENT_CAP_STEREO_3D: libc::c_uint = 1;
pub const DRM_CLIENT_CAP_UNIVERSAL_PLANES: libc::c_uint = 2;
pub const DRM_CLIENT_CAP_ATOMIC: libc::c_uint = 3;
pub const DRM_SYNCOBJ_CREATE_SIGNALED: libc::c_uint = 1;
pub const DRM_SYNCOBJ_FD_TO_HANDLE_FLAGS_IMPORT_SYNC_FILE: libc::c_uint = 1;
pub const DRM_SYNCOBJ_HANDLE_TO_FD_FLAGS_EXPORT_SYNC_FILE: libc::c_uint = 1;
pub const DRM_SYNCOBJ_WAIT_FLAGS_WAIT_ALL: libc::c_uint = 1;
pub const DRM_SYNCOBJ_WAIT_FLAGS_WAIT_FOR_SUBMIT: libc::c_uint = 2;
pub const DRM_DISPLAY_INFO_LEN: libc::c_uint = 32;
pub const DRM_CONNECTOR_NAME_LEN: libc::c_uint = 32;
pub const DRM_DISPLAY_MODE_LEN: libc::c_uint = 32;
pub const DRM_PROP_NAME_LEN: libc::c_uint = 32;
pub const DRM_MODE_TYPE_BUILTIN: libc::c_uint = 1;
pub const DRM_MODE_TYPE_CLOCK_C: libc::c_uint = 3;
pub const DRM_MODE_TYPE_CRTC_C: libc::c_uint = 5;
pub const DRM_MODE_TYPE_PREFERRED: libc::c_uint = 8;
pub const DRM_MODE_TYPE_DEFAULT: libc::c_uint = 16;
pub const DRM_MODE_TYPE_USERDEF: libc::c_uint = 32;
pub const DRM_MODE_TYPE_DRIVER: libc::c_uint = 64;
pub const DRM_MODE_FLAG_PHSYNC: libc::c_uint = 1;
pub const DRM_MODE_FLAG_NHSYNC: libc::c_uint = 2;
pub const DRM_MODE_FLAG_PVSYNC: libc::c_uint = 4;
pub const DRM_MODE_FLAG_NVSYNC: libc::c_uint = 8;
pub const DRM_MODE_FLAG_INTERLACE: libc::c_uint = 16;
pub const DRM_MODE_FLAG_DBLSCAN: libc::c_uint = 32;
pub const DRM_MODE_FLAG_CSYNC: libc::c_uint = 64;
pub const DRM_MODE_FLAG_PCSYNC: libc::c_uint = 128;
pub const DRM_MODE_FLAG_NCSYNC: libc::c_uint = 256;
pub const DRM_MODE_FLAG_HSKEW: libc::c_uint = 512;
pub const DRM_MODE_FLAG_BCAST: libc::c_uint = 1024;
pub const DRM_MODE_FLAG_PIXMUX: libc::c_uint = 2048;
pub const DRM_MODE_FLAG_DBLCLK: libc::c_uint = 4096;
pub const DRM_MODE_FLAG_CLKDIV2: libc::c_uint = 8192;
pub const DRM_MODE_FLAG_3D_MASK: libc::c_uint = 507904;
pub const DRM_MODE_FLAG_3D_NONE: libc::c_uint = 0;
pub const DRM_MODE_FLAG_3D_FRAME_PACKING: libc::c_uint = 16384;
pub const DRM_MODE_FLAG_3D_FIELD_ALTERNATIVE: libc::c_uint = 32768;
pub const DRM_MODE_FLAG_3D_LINE_ALTERNATIVE: libc::c_uint = 49152;
pub const DRM_MODE_FLAG_3D_SIDE_BY_SIDE_FULL: libc::c_uint = 65536;
pub const DRM_MODE_FLAG_3D_L_DEPTH: libc::c_uint = 81920;
pub const DRM_MODE_FLAG_3D_L_DEPTH_GFX_GFX_DEPTH: libc::c_uint = 98304;
pub const DRM_MODE_FLAG_3D_TOP_AND_BOTTOM: libc::c_uint = 114688;
pub const DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF: libc::c_uint = 131072;
pub const DRM_MODE_DPMS_ON: libc::c_uint = 0;
pub const DRM_MODE_DPMS_STANDBY: libc::c_uint = 1;
pub const DRM_MODE_DPMS_SUSPEND: libc::c_uint = 2;
pub const DRM_MODE_DPMS_OFF: libc::c_uint = 3;
pub const DRM_MODE_SCALE_NONE: libc::c_uint = 0;
pub const DRM_MODE_SCALE_FULLSCREEN: libc::c_uint = 1;
pub const DRM_MODE_SCALE_CENTER: libc::c_uint = 2;
pub const DRM_MODE_SCALE_ASPECT: libc::c_uint = 3;
pub const DRM_MODE_PICTURE_ASPECT_NONE: libc::c_uint = 0;
pub const DRM_MODE_PICTURE_ASPECT_4_3: libc::c_uint = 1;
pub const DRM_MODE_PICTURE_ASPECT_16_9: libc::c_uint = 2;
pub const DRM_MODE_DITHERING_OFF: libc::c_uint = 0;
pub const DRM_MODE_DITHERING_ON: libc::c_uint = 1;
pub const DRM_MODE_DITHERING_AUTO: libc::c_uint = 2;
pub const DRM_MODE_DIRTY_OFF: libc::c_uint = 0;
pub const DRM_MODE_DIRTY_ON: libc::c_uint = 1;
pub const DRM_MODE_DIRTY_ANNOTATE: libc::c_uint = 2;
pub const DRM_MODE_LINK_STATUS_GOOD: libc::c_uint = 0;
pub const DRM_MODE_LINK_STATUS_BAD: libc::c_uint = 1;
pub const DRM_MODE_ROTATE_0: libc::c_uint = 1;
pub const DRM_MODE_ROTATE_90: libc::c_uint = 2;
pub const DRM_MODE_ROTATE_180: libc::c_uint = 4;
pub const DRM_MODE_ROTATE_270: libc::c_uint = 8;
pub const DRM_MODE_ROTATE_MASK: libc::c_uint = 15;
pub const DRM_MODE_REFLECT_X: libc::c_uint = 16;
pub const DRM_MODE_REFLECT_Y: libc::c_uint = 32;
pub const DRM_MODE_REFLECT_MASK: libc::c_uint = 48;
pub const DRM_MODE_PRESENT_TOP_FIELD: libc::c_uint = 1;
pub const DRM_MODE_PRESENT_BOTTOM_FIELD: libc::c_uint = 2;
pub const DRM_MODE_ENCODER_NONE: libc::c_uint = 0;
pub const DRM_MODE_ENCODER_DAC: libc::c_uint = 1;
pub const DRM_MODE_ENCODER_TMDS: libc::c_uint = 2;
pub const DRM_MODE_ENCODER_LVDS: libc::c_uint = 3;
pub const DRM_MODE_ENCODER_TVDAC: libc::c_uint = 4;
pub const DRM_MODE_ENCODER_VIRTUAL: libc::c_uint = 5;
pub const DRM_MODE_ENCODER_DSI: libc::c_uint = 6;
pub const DRM_MODE_ENCODER_DPMST: libc::c_uint = 7;
pub const DRM_MODE_ENCODER_DPI: libc::c_uint = 8;
pub const DRM_MODE_CONNECTOR_Unknown: libc::c_uint = 0;
pub const DRM_MODE_CONNECTOR_VGA: libc::c_uint = 1;
pub const DRM_MODE_CONNECTOR_DVII: libc::c_uint = 2;
pub const DRM_MODE_CONNECTOR_DVID: libc::c_uint = 3;
pub const DRM_MODE_CONNECTOR_DVIA: libc::c_uint = 4;
pub const DRM_MODE_CONNECTOR_Composite: libc::c_uint = 5;
pub const DRM_MODE_CONNECTOR_SVIDEO: libc::c_uint = 6;
pub const DRM_MODE_CONNECTOR_LVDS: libc::c_uint = 7;
pub const DRM_MODE_CONNECTOR_Component: libc::c_uint = 8;
pub const DRM_MODE_CONNECTOR_9PinDIN: libc::c_uint = 9;
pub const DRM_MODE_CONNECTOR_DisplayPort: libc::c_uint = 10;
pub const DRM_MODE_CONNECTOR_HDMIA: libc::c_uint = 11;
pub const DRM_MODE_CONNECTOR_HDMIB: libc::c_uint = 12;
pub const DRM_MODE_CONNECTOR_TV: libc::c_uint = 13;
pub const DRM_MODE_CONNECTOR_eDP: libc::c_uint = 14;
pub const DRM_MODE_CONNECTOR_VIRTUAL: libc::c_uint = 15;
pub const DRM_MODE_CONNECTOR_DSI: libc::c_uint = 16;
pub const DRM_MODE_CONNECTOR_DPI: libc::c_uint = 17;
pub const DRM_MODE_PROP_PENDING: libc::c_uint = 1;
pub const DRM_MODE_PROP_RANGE: libc::c_uint = 2;
pub const DRM_MODE_PROP_IMMUTABLE: libc::c_uint = 4;
pub const DRM_MODE_PROP_ENUM: libc::c_uint = 8;
pub const DRM_MODE_PROP_BLOB: libc::c_uint = 16;
pub const DRM_MODE_PROP_BITMASK: libc::c_uint = 32;
pub const DRM_MODE_PROP_LEGACY_TYPE: libc::c_uint = 58;
pub const DRM_MODE_PROP_EXTENDED_TYPE: libc::c_uint = 65472;
pub const DRM_MODE_PROP_ATOMIC: libc::c_uint = 2147483648;
pub const DRM_MODE_OBJECT_CRTC: libc::c_uint = 3435973836;
pub const DRM_MODE_OBJECT_CONNECTOR: libc::c_uint = 3233857728;
pub const DRM_MODE_OBJECT_ENCODER: libc::c_uint = 3772834016;
pub const DRM_MODE_OBJECT_MODE: libc::c_uint = 3739147998;
pub const DRM_MODE_OBJECT_PROPERTY: libc::c_uint = 2964369584;
pub const DRM_MODE_OBJECT_FB: libc::c_uint = 4227595259;
pub const DRM_MODE_OBJECT_BLOB: libc::c_uint = 3149642683;
pub const DRM_MODE_OBJECT_PLANE: libc::c_uint = 4008636142;
pub const DRM_MODE_OBJECT_ANY: libc::c_uint = 0;
pub const DRM_MODE_FB_INTERLACED: libc::c_uint = 1;
pub const DRM_MODE_FB_MODIFIERS: libc::c_uint = 2;
pub const DRM_MODE_FB_DIRTY_ANNOTATE_COPY: libc::c_uint = 1;
pub const DRM_MODE_FB_DIRTY_ANNOTATE_FILL: libc::c_uint = 2;
pub const DRM_MODE_FB_DIRTY_FLAGS: libc::c_uint = 3;
pub const DRM_MODE_FB_DIRTY_MAX_CLIPS: libc::c_uint = 256;
pub const DRM_MODE_CURSOR_BO: libc::c_uint = 1;
pub const DRM_MODE_CURSOR_MOVE: libc::c_uint = 2;
pub const DRM_MODE_CURSOR_FLAGS: libc::c_uint = 3;
pub const DRM_MODE_PAGE_FLIP_EVENT: libc::c_uint = 1;
pub const DRM_MODE_PAGE_FLIP_ASYNC: libc::c_uint = 2;
pub const DRM_MODE_PAGE_FLIP_TARGET_ABSOLUTE: libc::c_uint = 4;
pub const DRM_MODE_PAGE_FLIP_TARGET_RELATIVE: libc::c_uint = 8;
pub const DRM_MODE_PAGE_FLIP_TARGET: libc::c_uint = 12;
pub const DRM_MODE_PAGE_FLIP_FLAGS: libc::c_uint = 15;
pub const DRM_MODE_ATOMIC_TEST_ONLY: libc::c_uint = 256;
pub const DRM_MODE_ATOMIC_NONBLOCK: libc::c_uint = 512;
pub const DRM_MODE_ATOMIC_ALLOW_MODESET: libc::c_uint = 1024;
pub const DRM_MODE_ATOMIC_FLAGS: libc::c_uint = 1795;
pub const FORMAT_BLOB_CURRENT: libc::c_uint = 1;
pub const DRM_IOCTL_BASE: u8 = 100u8;
pub const DRM_COMMAND_BASE: libc::c_uint = 64;
pub const DRM_COMMAND_END: libc::c_uint = 160;
pub const DRM_EVENT_VBLANK: libc::c_uint = 1;
pub const DRM_EVENT_FLIP_COMPLETE: libc::c_uint = 2;
extern "C" {
    pub fn ioctl(arg1: libc::c_int, arg2: libc::c_ulong, ...) -> libc::c_int;
}
pub type __int8_t = libc::c_schar;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_long;
pub type __uint64_t = libc::c_ulong;
pub type __clock_t = __int32_t;
pub type __critical_t = __int64_t;
pub type __double_t = f64;
pub type __float_t = f32;
pub type __intfptr_t = __int64_t;
pub type __intptr_t = __int64_t;
pub type __intmax_t = __int64_t;
pub type __int_fast8_t = __int32_t;
pub type __int_fast16_t = __int32_t;
pub type __int_fast32_t = __int32_t;
pub type __int_fast64_t = __int64_t;
pub type __int_least8_t = __int8_t;
pub type __int_least16_t = __int16_t;
pub type __int_least32_t = __int32_t;
pub type __int_least64_t = __int64_t;
pub type __ptrdiff_t = __int64_t;
pub type __register_t = __int64_t;
pub type __segsz_t = __int64_t;
pub type __size_t = __uint64_t;
pub type __ssize_t = __int64_t;
pub type __time_t = __int64_t;
pub type __uintfptr_t = __uint64_t;
pub type __uintptr_t = __uint64_t;
pub type __uintmax_t = __uint64_t;
pub type __uint_fast8_t = __uint32_t;
pub type __uint_fast16_t = __uint32_t;
pub type __uint_fast32_t = __uint32_t;
pub type __uint_fast64_t = __uint64_t;
pub type __uint_least8_t = __uint8_t;
pub type __uint_least16_t = __uint16_t;
pub type __uint_least32_t = __uint32_t;
pub type __uint_least64_t = __uint64_t;
pub type __u_register_t = __uint64_t;
pub type __vm_offset_t = __uint64_t;
pub type __vm_paddr_t = __uint64_t;
pub type __vm_size_t = __uint64_t;
pub type ___wchar_t = libc::c_int;
pub type __va_list = __builtin_va_list;
pub type __gnuc_va_list = __va_list;
pub type __blksize_t = __int32_t;
pub type __blkcnt_t = __int64_t;
pub type __clockid_t = __int32_t;
pub type __fflags_t = __uint32_t;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint64_t;
pub type __gid_t = __uint32_t;
pub type __id_t = __int64_t;
pub type __ino_t = __uint64_t;
pub type __key_t = libc::c_long;
pub type __lwpid_t = __int32_t;
pub type __mode_t = __uint16_t;
pub type __accmode_t = libc::c_int;
pub type __nl_item = libc::c_int;
pub type __nlink_t = __uint64_t;
pub type __off_t = __int64_t;
pub type __off64_t = __int64_t;
pub type __pid_t = __int32_t;
pub type __rlim_t = __int64_t;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __suseconds_t = libc::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __timer {
    _unused: [u8; 0],
}
pub type __timer_t = *mut __timer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __mq {
    _unused: [u8; 0],
}
pub type __mqd_t = *mut __mq;
pub type __uid_t = __uint32_t;
pub type __useconds_t = libc::c_uint;
pub type __cpuwhich_t = libc::c_int;
pub type __cpulevel_t = libc::c_int;
pub type __cpusetid_t = libc::c_int;
pub type __ct_rune_t = libc::c_int;
pub type __rune_t = __ct_rune_t;
pub type __wint_t = __ct_rune_t;
pub type __char16_t = __uint_least16_t;
pub type __char32_t = __uint_least32_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __max_align_t {
    pub __max_align1: libc::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align2: f64,
}
#[test]
fn bindgen_test_layout___max_align_t() {
    assert_eq!(
        ::core::mem::size_of::<__max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(__max_align_t))
    );
    assert_eq!(
        unsafe { &(*(0 as *const __max_align_t)).__max_align1 as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(__max_align_t),
            "::",
            stringify!(__max_align1)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const __max_align_t)).__max_align2 as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(__max_align_t),
            "::",
            stringify!(__max_align2)
        )
    );
}
impl Clone for __max_align_t {
    fn clone(&self) -> Self {
        *self
    }
}
pub type __dev_t = __uint64_t;
pub type __fixpt_t = __uint32_t;
#[repr(C)]
#[derive(Copy)]
pub union __mbstate_t {
    pub __mbstate8: [libc::c_char; 128usize],
    pub _mbstateL: __int64_t,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(0 as *const __mbstate_t)).__mbstate8 as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const __mbstate_t))._mbstateL as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self {
        *self
    }
}
impl Default for __mbstate_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type __rman_res_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlockattr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_spinlock {
    _unused: [u8; 0],
}
pub type pthread_t = *mut pthread;
pub type pthread_attr_t = *mut pthread_attr;
pub type pthread_mutex_t = *mut pthread_mutex;
pub type pthread_mutexattr_t = *mut pthread_mutex_attr;
pub type pthread_cond_t = *mut pthread_cond;
pub type pthread_condattr_t = *mut pthread_cond_attr;
pub type pthread_key_t = libc::c_int;
pub type pthread_once_t = pthread_once;
pub type pthread_rwlock_t = *mut pthread_rwlock;
pub type pthread_rwlockattr_t = *mut pthread_rwlockattr;
pub type pthread_barrier_t = *mut pthread_barrier;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrierattr {
    _unused: [u8; 0],
}
pub type pthread_barrierattr_t = *mut pthread_barrierattr;
pub type pthread_spinlock_t = *mut pthread_spinlock;
pub type pthread_addr_t = *mut libc::c_void;
pub type pthread_startroutine_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut libc::c_void) -> *mut libc::c_void,
>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_once {
    pub state: libc::c_int,
    pub mutex: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_pthread_once() {
    assert_eq!(
        ::core::mem::size_of::<pthread_once>(),
        16usize,
        concat!("Size of: ", stringify!(pthread_once))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_once>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_once))
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_once)).state as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_once),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const pthread_once)).mutex as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(pthread_once),
            "::",
            stringify!(mutex)
        )
    );
}
impl Clone for pthread_once {
    fn clone(&self) -> Self {
        *self
    }
}
impl Default for pthread_once {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type u_char = libc::c_uchar;
pub type u_short = libc::c_ushort;
pub type u_int = libc::c_uint;
pub type u_long = libc::c_ulong;
pub type ushort = libc::c_ushort;
pub type uint = libc::c_uint;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type u_quad_t = __uint64_t;
pub type quad_t = __int64_t;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut libc::c_char;
pub type c_caddr_t = *const libc::c_char;
pub type blksize_t = __blksize_t;
pub type cpuwhich_t = __cpuwhich_t;
pub type cpulevel_t = __cpulevel_t;
pub type cpusetid_t = __cpusetid_t;
pub type blkcnt_t = __blkcnt_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type critical_t = __critical_t;
pub type daddr_t = __int64_t;
pub type dev_t = __dev_t;
pub type fflags_t = __fflags_t;
pub type fixpt_t = __fixpt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type gid_t = __gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type key_t = __key_t;
pub type lwpid_t = __lwpid_t;
pub type mode_t = __mode_t;
pub type accmode_t = __accmode_t;
pub type nlink_t = __nlink_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type pid_t = __pid_t;
pub type register_t = __register_t;
pub type rlim_t = __rlim_t;
pub type sbintime_t = __int64_t;
pub type segsz_t = __segsz_t;
pub type suseconds_t = __suseconds_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type mqd_t = __mqd_t;
pub type u_register_t = __u_register_t;
pub type uid_t = __uid_t;
pub type useconds_t = __useconds_t;
pub type cap_ioctl_t = libc::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cap_rights {
    _unused: [u8; 0],
}
pub type cap_rights_t = cap_rights;
pub type vm_offset_t = __vm_offset_t;
pub type vm_ooffset_t = __int64_t;
pub type vm_paddr_t = __vm_paddr_t;
pub type vm_pindex_t = __uint64_t;
pub type vm_size_t = __vm_size_t;
pub type rman_res_t = __rman_res_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __sigset {
    pub __bits: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout___sigset() {
    assert_eq!(
        ::core::mem::size_of::<__sigset>(),
        16usize,
        concat!("Size of: ", stringify!(__sigset))
    );
    assert_eq!(
        ::core::mem::align_of::<__sigset>(),
        4usize,
        concat!("Alignment of ", stringify!(__sigset))
    );
    assert_eq!(
        unsafe { &(*(0 as *const __sigset)).__bits as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(__sigset),
            "::",
            stringify!(__bits)
        )
    );
}
impl Clone for __sigset {
    fn clone(&self) -> Self {
        *self
    }
}
pub type __sigset_t = __sigset;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::core::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::core::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(0 as *const timeval)).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const timeval)).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
impl Clone for timeval {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: libc::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::core::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::core::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(0 as *const timespec)).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const timespec)).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
impl Clone for timespec {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::core::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::core::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(0 as *const itimerspec)).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const itimerspec)).it_value as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
impl Clone for itimerspec {
    fn clone(&self) -> Self {
        *self
    }
}
pub type __fd_mask = libc::c_ulong;
pub type fd_mask = __fd_mask;
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::core::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::core::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(0 as *const fd_set)).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
impl Clone for fd_set {
    fn clone(&self) -> Self {
        *self
    }
}
extern "C" {
    pub fn pselect(
        arg1: libc::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *const timespec,
        arg6: *const sigset_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn select(
        arg1: libc::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *mut timeval,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ftruncate(arg1: libc::c_int, arg2: off_t) -> libc::c_int;
}
extern "C" {
    pub fn lseek(arg1: libc::c_int, arg2: off_t, arg3: libc::c_int) -> off_t;
}
extern "C" {
    pub fn mmap(
        arg1: *mut libc::c_void,
        arg2: usize,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: off_t,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn truncate(arg1: *const libc::c_char, arg2: off_t) -> libc::c_int;
}
pub type __s8 = i8;
pub type __u8 = u8;
pub type __s16 = i16;
pub type __u16 = u16;
pub type __s32 = i32;
pub type __u32 = u32;
pub type __s64 = i64;
pub type __u64 = u64;
pub type __kernel_size_t = usize;
pub type drm_handle_t = libc::c_ulong;
pub type drm_context_t = libc::c_uint;
pub type drm_drawable_t = libc::c_uint;
pub type drm_magic_t = libc::c_uint;
/// Cliprect.
///
/// \warning: If you change this structure, make sure you change
/// XF86DRIClipRectRec in the server as well
///
/// \note KW: Actually it's illegal to change either for
/// backwards-compatibility reasons.
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_clip_rect {
    pub x1: libc::c_ushort,
    pub y1: libc::c_ushort,
    pub x2: libc::c_ushort,
    pub y2: libc::c_ushort,
}
#[test]
fn bindgen_test_layout_drm_clip_rect() {
    assert_eq!(
        ::core::mem::size_of::<drm_clip_rect>(),
        8usize,
        concat!("Size of: ", stringify!(drm_clip_rect))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_clip_rect>(),
        2usize,
        concat!("Alignment of ", stringify!(drm_clip_rect))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_clip_rect)).x1 as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_clip_rect),
            "::",
            stringify!(x1)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_clip_rect)).y1 as *const _ as usize },
        2usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_clip_rect),
            "::",
            stringify!(y1)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_clip_rect)).x2 as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_clip_rect),
            "::",
            stringify!(x2)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_clip_rect)).y2 as *const _ as usize },
        6usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_clip_rect),
            "::",
            stringify!(y2)
        )
    );
}
impl Clone for drm_clip_rect {
    fn clone(&self) -> Self {
        *self
    }
}
/// Drawable information.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_drawable_info {
    pub num_rects: libc::c_uint,
    pub rects: *mut drm_clip_rect,
}
#[test]
fn bindgen_test_layout_drm_drawable_info() {
    assert_eq!(
        ::core::mem::size_of::<drm_drawable_info>(),
        16usize,
        concat!("Size of: ", stringify!(drm_drawable_info))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_drawable_info>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_drawable_info))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_drawable_info)).num_rects as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_drawable_info),
            "::",
            stringify!(num_rects)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_drawable_info)).rects as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_drawable_info),
            "::",
            stringify!(rects)
        )
    );
}
impl Clone for drm_drawable_info {
    fn clone(&self) -> Self {
        *self
    }
}
impl Default for drm_drawable_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
/// Texture region,
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_tex_region {
    pub next: libc::c_uchar,
    pub prev: libc::c_uchar,
    pub in_use: libc::c_uchar,
    pub padding: libc::c_uchar,
    pub age: libc::c_uint,
}
#[test]
fn bindgen_test_layout_drm_tex_region() {
    assert_eq!(
        ::core::mem::size_of::<drm_tex_region>(),
        8usize,
        concat!("Size of: ", stringify!(drm_tex_region))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_tex_region>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_tex_region))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_tex_region)).next as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_tex_region),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_tex_region)).prev as *const _ as usize },
        1usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_tex_region),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_tex_region)).in_use as *const _ as usize },
        2usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_tex_region),
            "::",
            stringify!(in_use)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_tex_region)).padding as *const _ as usize },
        3usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_tex_region),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_tex_region)).age as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_tex_region),
            "::",
            stringify!(age)
        )
    );
}
impl Clone for drm_tex_region {
    fn clone(&self) -> Self {
        *self
    }
}
/// Hardware lock.
///
/// The lock structure is a simple cache-line aligned integer.  To avoid
/// processor bus contention on a multiprocessor system, there should not be any
/// other data stored in the same cache line.
#[repr(C)]
#[derive(Copy)]
pub struct drm_hw_lock {
    /// < lock variable
    pub lock: libc::c_uint,
    /// < Pad to cache line
    pub padding: [libc::c_char; 60usize],
}
#[test]
fn bindgen_test_layout_drm_hw_lock() {
    assert_eq!(
        ::core::mem::size_of::<drm_hw_lock>(),
        64usize,
        concat!("Size of: ", stringify!(drm_hw_lock))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_hw_lock>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_hw_lock))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_hw_lock)).lock as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_hw_lock),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_hw_lock)).padding as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_hw_lock),
            "::",
            stringify!(padding)
        )
    );
}
impl Clone for drm_hw_lock {
    fn clone(&self) -> Self {
        *self
    }
}
impl Default for drm_hw_lock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
/// DRM_IOCTL_VERSION ioctl argument type.
///
/// \sa drmGetVersion().
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_version {
    /// < Major version
    pub version_major: libc::c_int,
    /// < Minor version
    pub version_minor: libc::c_int,
    /// < Patch level
    pub version_patchlevel: libc::c_int,
    /// < Length of name buffer
    pub name_len: __kernel_size_t,
    /// < Name of driver
    pub name: *mut libc::c_char,
    /// < Length of date buffer
    pub date_len: __kernel_size_t,
    /// < User-space buffer to hold date
    pub date: *mut libc::c_char,
    /// < Length of desc buffer
    pub desc_len: __kernel_size_t,
    /// < User-space buffer to hold desc
    pub desc: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_drm_version() {
    assert_eq!(
        ::core::mem::size_of::<drm_version>(),
        64usize,
        concat!("Size of: ", stringify!(drm_version))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_version>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_version))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_version)).version_major as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_version),
            "::",
            stringify!(version_major)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_version)).version_minor as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_version),
            "::",
            stringify!(version_minor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_version)).version_patchlevel as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_version),
            "::",
            stringify!(version_patchlevel)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_version)).name_len as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_version),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_version)).name as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_version),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_version)).date_len as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_version),
            "::",
            stringify!(date_len)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_version)).date as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_version),
            "::",
            stringify!(date)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_version)).desc_len as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_version),
            "::",
            stringify!(desc_len)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_version)).desc as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_version),
            "::",
            stringify!(desc)
        )
    );
}
impl Clone for drm_version {
    fn clone(&self) -> Self {
        *self
    }
}
impl Default for drm_version {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
/// DRM_IOCTL_GET_UNIQUE ioctl argument type.
///
/// \sa drmGetBusid() and drmSetBusId().
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_unique {
    /// < Length of unique
    pub unique_len: __kernel_size_t,
    /// < Unique name for driver instantiation
    pub unique: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_drm_unique() {
    assert_eq!(
        ::core::mem::size_of::<drm_unique>(),
        16usize,
        concat!("Size of: ", stringify!(drm_unique))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_unique>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_unique))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_unique)).unique_len as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_unique),
            "::",
            stringify!(unique_len)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_unique)).unique as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_unique),
            "::",
            stringify!(unique)
        )
    );
}
impl Clone for drm_unique {
    fn clone(&self) -> Self {
        *self
    }
}
impl Default for drm_unique {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_list {
    /// < Length of user-space structures
    pub count: libc::c_int,
    pub version: *mut drm_version,
}
#[test]
fn bindgen_test_layout_drm_list() {
    assert_eq!(
        ::core::mem::size_of::<drm_list>(),
        16usize,
        concat!("Size of: ", stringify!(drm_list))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_list>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_list))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_list)).count as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_list),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_list)).version as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_list),
            "::",
            stringify!(version)
        )
    );
}
impl Clone for drm_list {
    fn clone(&self) -> Self {
        *self
    }
}
impl Default for drm_list {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_block {
    pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout_drm_block() {
    assert_eq!(
        ::core::mem::size_of::<drm_block>(),
        4usize,
        concat!("Size of: ", stringify!(drm_block))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_block>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_block))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_block)).unused as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_block),
            "::",
            stringify!(unused)
        )
    );
}
impl Clone for drm_block {
    fn clone(&self) -> Self {
        *self
    }
}
/// DRM_IOCTL_CONTROL ioctl argument type.
///
/// \sa drmCtlInstHandler() and drmCtlUninstHandler().
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_control {
    pub func: drm_control__bindgen_ty_1,
    pub irq: libc::c_int,
}
pub const drm_control_DRM_ADD_COMMAND: drm_control__bindgen_ty_1 = 0;
pub const drm_control_DRM_RM_COMMAND: drm_control__bindgen_ty_1 = 1;
pub const drm_control_DRM_INST_HANDLER: drm_control__bindgen_ty_1 = 2;
pub const drm_control_DRM_UNINST_HANDLER: drm_control__bindgen_ty_1 = 3;
pub type drm_control__bindgen_ty_1 = libc::c_uint;
#[test]
fn bindgen_test_layout_drm_control() {
    assert_eq!(
        ::core::mem::size_of::<drm_control>(),
        8usize,
        concat!("Size of: ", stringify!(drm_control))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_control>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_control))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_control)).func as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_control),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_control)).irq as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_control),
            "::",
            stringify!(irq)
        )
    );
}
impl Clone for drm_control {
    fn clone(&self) -> Self {
        *self
    }
}
impl Default for drm_control {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const drm_map_type__DRM_FRAME_BUFFER: drm_map_type = 0;
pub const drm_map_type__DRM_REGISTERS: drm_map_type = 1;
pub const drm_map_type__DRM_SHM: drm_map_type = 2;
pub const drm_map_type__DRM_AGP: drm_map_type = 3;
pub const drm_map_type__DRM_SCATTER_GATHER: drm_map_type = 4;
pub const drm_map_type__DRM_CONSISTENT: drm_map_type = 5;
pub type drm_map_type = libc::c_uint;
pub const drm_map_flags__DRM_RESTRICTED: drm_map_flags = 1;
pub const drm_map_flags__DRM_READ_ONLY: drm_map_flags = 2;
pub const drm_map_flags__DRM_LOCKED: drm_map_flags = 4;
pub const drm_map_flags__DRM_KERNEL: drm_map_flags = 8;
pub const drm_map_flags__DRM_WRITE_COMBINING: drm_map_flags = 16;
pub const drm_map_flags__DRM_CONTAINS_LOCK: drm_map_flags = 32;
pub const drm_map_flags__DRM_REMOVABLE: drm_map_flags = 64;
pub const drm_map_flags__DRM_DRIVER: drm_map_flags = 128;
pub type drm_map_flags = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_ctx_priv_map {
    /// < Context requesting private mapping
    pub ctx_id: libc::c_uint,
    /// < Handle of map
    pub handle: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_drm_ctx_priv_map() {
    assert_eq!(
        ::core::mem::size_of::<drm_ctx_priv_map>(),
        16usize,
        concat!("Size of: ", stringify!(drm_ctx_priv_map))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_ctx_priv_map>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_ctx_priv_map))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_ctx_priv_map)).ctx_id as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_ctx_priv_map),
            "::",
            stringify!(ctx_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_ctx_priv_map)).handle as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_ctx_priv_map),
            "::",
            stringify!(handle)
        )
    );
}
impl Clone for drm_ctx_priv_map {
    fn clone(&self) -> Self {
        *self
    }
}
impl Default for drm_ctx_priv_map {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
/// DRM_IOCTL_GET_MAP, DRM_IOCTL_ADD_MAP and DRM_IOCTL_RM_MAP ioctls
/// argument type.
///
/// \sa drmAddMap().
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_map {
    /// < Requested physical address (0 for SAREA)
    pub offset: libc::c_ulong,
    /// < Requested physical size (bytes)
    pub size: libc::c_ulong,
    /// < Type of memory to map
    pub type_: drm_map_type,
    /// < Flags
    pub flags: drm_map_flags,
    /// < User-space: "Handle" to pass to mmap() */
    /// /**< Kernel-space: kernel-virtual address
    pub handle: *mut libc::c_void,
    /// < MTRR slot used
    pub mtrr: libc::c_int,
}
#[test]
fn bindgen_test_layout_drm_map() {
    assert_eq!(
        ::core::mem::size_of::<drm_map>(),
        40usize,
        concat!("Size of: ", stringify!(drm_map))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_map>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_map))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_map)).offset as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_map),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_map)).size as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_map),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_map)).type_ as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_map),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_map)).flags as *const _ as usize },
        20usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_map),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_map)).handle as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_map),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_map)).mtrr as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_map),
            "::",
            stringify!(mtrr)
        )
    );
}
impl Clone for drm_map {
    fn clone(&self) -> Self {
        *self
    }
}
impl Default for drm_map {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
/// DRM_IOCTL_GET_CLIENT ioctl argument type.
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_client {
    /// < Which client desired?
    pub idx: libc::c_int,
    /// < Is client authenticated?
    pub auth: libc::c_int,
    /// < Process ID
    pub pid: libc::c_ulong,
    /// < User ID
    pub uid: libc::c_ulong,
    /// < Magic
    pub magic: libc::c_ulong,
    /// < Ioctl count
    pub iocs: libc::c_ulong,
}
#[test]
fn bindgen_test_layout_drm_client() {
    assert_eq!(
        ::core::mem::size_of::<drm_client>(),
        40usize,
        concat!("Size of: ", stringify!(drm_client))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_client>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_client))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_client)).idx as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_client),
            "::",
            stringify!(idx)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_client)).auth as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_client),
            "::",
            stringify!(auth)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_client)).pid as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_client),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_client)).uid as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_client),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_client)).magic as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_client),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_client)).iocs as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_client),
            "::",
            stringify!(iocs)
        )
    );
}
impl Clone for drm_client {
    fn clone(&self) -> Self {
        *self
    }
}
pub const drm_stat_type__DRM_STAT_LOCK: drm_stat_type = 0;
pub const drm_stat_type__DRM_STAT_OPENS: drm_stat_type = 1;
pub const drm_stat_type__DRM_STAT_CLOSES: drm_stat_type = 2;
pub const drm_stat_type__DRM_STAT_IOCTLS: drm_stat_type = 3;
pub const drm_stat_type__DRM_STAT_LOCKS: drm_stat_type = 4;
pub const drm_stat_type__DRM_STAT_UNLOCKS: drm_stat_type = 5;
pub const drm_stat_type__DRM_STAT_VALUE: drm_stat_type = 6;
pub const drm_stat_type__DRM_STAT_BYTE: drm_stat_type = 7;
pub const drm_stat_type__DRM_STAT_COUNT: drm_stat_type = 8;
pub const drm_stat_type__DRM_STAT_IRQ: drm_stat_type = 9;
pub const drm_stat_type__DRM_STAT_PRIMARY: drm_stat_type = 10;
pub const drm_stat_type__DRM_STAT_SECONDARY: drm_stat_type = 11;
pub const drm_stat_type__DRM_STAT_DMA: drm_stat_type = 12;
pub const drm_stat_type__DRM_STAT_SPECIAL: drm_stat_type = 13;
pub const drm_stat_type__DRM_STAT_MISSED: drm_stat_type = 14;
pub type drm_stat_type = libc::c_uint;
/// DRM_IOCTL_GET_STATS ioctl argument type.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_stats {
    pub count: libc::c_ulong,
    pub data: [drm_stats__bindgen_ty_1; 15usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_stats__bindgen_ty_1 {
    pub value: libc::c_ulong,
    pub type_: drm_stat_type,
}
#[test]
fn bindgen_test_layout_drm_stats__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<drm_stats__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(drm_stats__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_stats__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_stats__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_stats__bindgen_ty_1)).value as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_stats__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_stats__bindgen_ty_1)).type_ as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_stats__bindgen_ty_1),
            "::",
            stringify!(type_)
        )
    );
}
impl Clone for drm_stats__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl Default for drm_stats__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_drm_stats() {
    assert_eq!(
        ::core::mem::size_of::<drm_stats>(),
        248usize,
        concat!("Size of: ", stringify!(drm_stats))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_stats))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_stats)).count as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_stats),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_stats)).data as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_stats),
            "::",
            stringify!(data)
        )
    );
}
impl Clone for drm_stats {
    fn clone(&self) -> Self {
        *self
    }
}
impl Default for drm_stats {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const drm_lock_flags__DRM_LOCK_READY: drm_lock_flags = 1;
pub const drm_lock_flags__DRM_LOCK_QUIESCENT: drm_lock_flags = 2;
pub const drm_lock_flags__DRM_LOCK_FLUSH: drm_lock_flags = 4;
pub const drm_lock_flags__DRM_LOCK_FLUSH_ALL: drm_lock_flags = 8;
pub const drm_lock_flags__DRM_HALT_ALL_QUEUES: drm_lock_flags = 16;
pub const drm_lock_flags__DRM_HALT_CUR_QUEUES: drm_lock_flags = 32;
pub type drm_lock_flags = libc::c_uint;
/// DRM_IOCTL_LOCK, DRM_IOCTL_UNLOCK and DRM_IOCTL_FINISH ioctl argument type.
///
/// \sa drmGetLock() and drmUnlock().
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_lock {
    pub context: libc::c_int,
    pub flags: drm_lock_flags,
}
#[test]
fn bindgen_test_layout_drm_lock() {
    assert_eq!(
        ::core::mem::size_of::<drm_lock>(),
        8usize,
        concat!("Size of: ", stringify!(drm_lock))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_lock>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_lock))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_lock)).context as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_lock),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_lock)).flags as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_lock),
            "::",
            stringify!(flags)
        )
    );
}
impl Clone for drm_lock {
    fn clone(&self) -> Self {
        *self
    }
}
impl Default for drm_lock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const drm_dma_flags__DRM_DMA_BLOCK: drm_dma_flags = 1;
pub const drm_dma_flags__DRM_DMA_WHILE_LOCKED: drm_dma_flags = 2;
pub const drm_dma_flags__DRM_DMA_PRIORITY: drm_dma_flags = 4;
pub const drm_dma_flags__DRM_DMA_WAIT: drm_dma_flags = 16;
pub const drm_dma_flags__DRM_DMA_SMALLER_OK: drm_dma_flags = 32;
pub const drm_dma_flags__DRM_DMA_LARGER_OK: drm_dma_flags = 64;
pub type drm_dma_flags = libc::c_uint;
/// DRM_IOCTL_ADD_BUFS and DRM_IOCTL_MARK_BUFS ioctl argument type.
///
/// \sa drmAddBufs().
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_buf_desc {
    /// < Number of buffers of this size
    pub count: libc::c_int,
    /// < Size in bytes
    pub size: libc::c_int,
    /// < Low water mark
    pub low_mark: libc::c_int,
    /// < High water mark
    pub high_mark: libc::c_int,
    pub flags: drm_buf_desc__bindgen_ty_1,
    /// <
    /// Start address of where the AGP buffers are
    /// in the AGP aperture
    pub agp_start: libc::c_ulong,
}
pub const drm_buf_desc__DRM_PAGE_ALIGN: drm_buf_desc__bindgen_ty_1 = 1;
pub const drm_buf_desc__DRM_AGP_BUFFER: drm_buf_desc__bindgen_ty_1 = 2;
pub const drm_buf_desc__DRM_SG_BUFFER: drm_buf_desc__bindgen_ty_1 = 4;
pub const drm_buf_desc__DRM_FB_BUFFER: drm_buf_desc__bindgen_ty_1 = 8;
pub const drm_buf_desc__DRM_PCI_BUFFER_RO: drm_buf_desc__bindgen_ty_1 = 16;
pub type drm_buf_desc__bindgen_ty_1 = libc::c_uint;
#[test]
fn bindgen_test_layout_drm_buf_desc() {
    assert_eq!(
        ::core::mem::size_of::<drm_buf_desc>(),
        32usize,
        concat!("Size of: ", stringify!(drm_buf_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_buf_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_buf_desc))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_buf_desc)).count as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_buf_desc),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_buf_desc)).size as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_buf_desc),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_buf_desc)).low_mark as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_buf_desc),
            "::",
            stringify!(low_mark)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_buf_desc)).high_mark as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_buf_desc),
            "::",
            stringify!(high_mark)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_buf_desc)).flags as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_buf_desc),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_buf_desc)).agp_start as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_buf_desc),
            "::",
            stringify!(agp_start)
        )
    );
}
impl Clone for drm_buf_desc {
    fn clone(&self) -> Self {
        *self
    }
}
impl Default for drm_buf_desc {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
/// DRM_IOCTL_INFO_BUFS ioctl argument type.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_buf_info {
    /// < Entries in list
    pub count: libc::c_int,
    pub list: *mut drm_buf_desc,
}
#[test]
fn bindgen_test_layout_drm_buf_info() {
    assert_eq!(
        ::core::mem::size_of::<drm_buf_info>(),
        16usize,
        concat!("Size of: ", stringify!(drm_buf_info))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_buf_info>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_buf_info))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_buf_info)).count as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_buf_info),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_buf_info)).list as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_buf_info),
            "::",
            stringify!(list)
        )
    );
}
impl Clone for drm_buf_info {
    fn clone(&self) -> Self {
        *self
    }
}
impl Default for drm_buf_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
/// DRM_IOCTL_FREE_BUFS ioctl argument type.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_buf_free {
    pub count: libc::c_int,
    pub list: *mut libc::c_int,
}
#[test]
fn bindgen_test_layout_drm_buf_free() {
    assert_eq!(
        ::core::mem::size_of::<drm_buf_free>(),
        16usize,
        concat!("Size of: ", stringify!(drm_buf_free))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_buf_free>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_buf_free))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_buf_free)).count as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_buf_free),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_buf_free)).list as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_buf_free),
            "::",
            stringify!(list)
        )
    );
}
impl Clone for drm_buf_free {
    fn clone(&self) -> Self {
        *self
    }
}
impl Default for drm_buf_free {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
/// Buffer information
///
/// \sa drm_buf_map.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_buf_pub {
    /// < Index into the master buffer list
    pub idx: libc::c_int,
    /// < Buffer size
    pub total: libc::c_int,
    /// < Amount of buffer in use (for DMA)
    pub used: libc::c_int,
    /// < Address of buffer
    pub address: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_drm_buf_pub() {
    assert_eq!(
        ::core::mem::size_of::<drm_buf_pub>(),
        24usize,
        concat!("Size of: ", stringify!(drm_buf_pub))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_buf_pub>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_buf_pub))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_buf_pub)).idx as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_buf_pub),
            "::",
            stringify!(idx)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_buf_pub)).total as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_buf_pub),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_buf_pub)).used as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_buf_pub),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_buf_pub)).address as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_buf_pub),
            "::",
            stringify!(address)
        )
    );
}
impl Clone for drm_buf_pub {
    fn clone(&self) -> Self {
        *self
    }
}
impl Default for drm_buf_pub {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
/// DRM_IOCTL_MAP_BUFS ioctl argument type.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_buf_map {
    /// < Length of the buffer list
    pub count: libc::c_int,
    /// < Mmap'd area in user-virtual
    pub virtual_: *mut libc::c_void,
    /// < Buffer information
    pub list: *mut drm_buf_pub,
}
#[test]
fn bindgen_test_layout_drm_buf_map() {
    assert_eq!(
        ::core::mem::size_of::<drm_buf_map>(),
        24usize,
        concat!("Size of: ", stringify!(drm_buf_map))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_buf_map>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_buf_map))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_buf_map)).count as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_buf_map),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_buf_map)).virtual_ as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_buf_map),
            "::",
            stringify!(virtual_)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_buf_map)).list as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_buf_map),
            "::",
            stringify!(list)
        )
    );
}
impl Clone for drm_buf_map {
    fn clone(&self) -> Self {
        *self
    }
}
impl Default for drm_buf_map {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
/// DRM_IOCTL_DMA ioctl argument type.
///
/// Indices here refer to the offset into the buffer list in drm_buf_get.
///
/// \sa drmDMA().
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_dma {
    /// < Context handle
    pub context: libc::c_int,
    /// < Number of buffers to send
    pub send_count: libc::c_int,
    /// < List of handles to buffers
    pub send_indices: *mut libc::c_int,
    /// < Lengths of data to send
    pub send_sizes: *mut libc::c_int,
    /// < Flags
    pub flags: drm_dma_flags,
    /// < Number of buffers requested
    pub request_count: libc::c_int,
    /// < Desired size for buffers
    pub request_size: libc::c_int,
    /// < Buffer information
    pub request_indices: *mut libc::c_int,
    pub request_sizes: *mut libc::c_int,
    /// < Number of buffers granted
    pub granted_count: libc::c_int,
}
#[test]
fn bindgen_test_layout_drm_dma() {
    assert_eq!(
        ::core::mem::size_of::<drm_dma>(),
        64usize,
        concat!("Size of: ", stringify!(drm_dma))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_dma>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_dma))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_dma)).context as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_dma),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_dma)).send_count as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_dma),
            "::",
            stringify!(send_count)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_dma)).send_indices as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_dma),
            "::",
            stringify!(send_indices)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_dma)).send_sizes as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_dma),
            "::",
            stringify!(send_sizes)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_dma)).flags as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_dma),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_dma)).request_count as *const _ as usize },
        28usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_dma),
            "::",
            stringify!(request_count)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_dma)).request_size as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_dma),
            "::",
            stringify!(request_size)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_dma)).request_indices as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_dma),
            "::",
            stringify!(request_indices)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_dma)).request_sizes as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_dma),
            "::",
            stringify!(request_sizes)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_dma)).granted_count as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_dma),
            "::",
            stringify!(granted_count)
        )
    );
}
impl Clone for drm_dma {
    fn clone(&self) -> Self {
        *self
    }
}
impl Default for drm_dma {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const drm_ctx_flags__DRM_CONTEXT_PRESERVED: drm_ctx_flags = 1;
pub const drm_ctx_flags__DRM_CONTEXT_2DONLY: drm_ctx_flags = 2;
pub type drm_ctx_flags = libc::c_uint;
/// DRM_IOCTL_ADD_CTX ioctl argument type.
///
/// \sa drmCreateContext() and drmDestroyContext().
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_ctx {
    pub handle: drm_context_t,
    pub flags: drm_ctx_flags,
}
#[test]
fn bindgen_test_layout_drm_ctx() {
    assert_eq!(
        ::core::mem::size_of::<drm_ctx>(),
        8usize,
        concat!("Size of: ", stringify!(drm_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_ctx>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_ctx))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_ctx)).handle as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_ctx),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_ctx)).flags as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_ctx),
            "::",
            stringify!(flags)
        )
    );
}
impl Clone for drm_ctx {
    fn clone(&self) -> Self {
        *self
    }
}
impl Default for drm_ctx {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
/// DRM_IOCTL_RES_CTX ioctl argument type.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_ctx_res {
    pub count: libc::c_int,
    pub contexts: *mut drm_ctx,
}
#[test]
fn bindgen_test_layout_drm_ctx_res() {
    assert_eq!(
        ::core::mem::size_of::<drm_ctx_res>(),
        16usize,
        concat!("Size of: ", stringify!(drm_ctx_res))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_ctx_res>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_ctx_res))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_ctx_res)).count as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_ctx_res),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_ctx_res)).contexts as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_ctx_res),
            "::",
            stringify!(contexts)
        )
    );
}
impl Clone for drm_ctx_res {
    fn clone(&self) -> Self {
        *self
    }
}
impl Default for drm_ctx_res {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
/// DRM_IOCTL_ADD_DRAW and DRM_IOCTL_RM_DRAW ioctl argument type.
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_draw {
    pub handle: drm_drawable_t,
}
#[test]
fn bindgen_test_layout_drm_draw() {
    assert_eq!(
        ::core::mem::size_of::<drm_draw>(),
        4usize,
        concat!("Size of: ", stringify!(drm_draw))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_draw>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_draw))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_draw)).handle as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_draw),
            "::",
            stringify!(handle)
        )
    );
}
impl Clone for drm_draw {
    fn clone(&self) -> Self {
        *self
    }
}
pub const drm_drawable_info_type_t_DRM_DRAWABLE_CLIPRECTS: drm_drawable_info_type_t = 0;
pub type drm_drawable_info_type_t = libc::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_update_draw {
    pub handle: drm_drawable_t,
    pub type_: libc::c_uint,
    pub num: libc::c_uint,
    pub data: libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drm_update_draw() {
    assert_eq!(
        ::core::mem::size_of::<drm_update_draw>(),
        24usize,
        concat!("Size of: ", stringify!(drm_update_draw))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_update_draw>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_update_draw))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_update_draw)).handle as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_update_draw),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_update_draw)).type_ as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_update_draw),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_update_draw)).num as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_update_draw),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_update_draw)).data as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_update_draw),
            "::",
            stringify!(data)
        )
    );
}
impl Clone for drm_update_draw {
    fn clone(&self) -> Self {
        *self
    }
}
/// DRM_IOCTL_GET_MAGIC and DRM_IOCTL_AUTH_MAGIC ioctl argument type.
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_auth {
    pub magic: drm_magic_t,
}
#[test]
fn bindgen_test_layout_drm_auth() {
    assert_eq!(
        ::core::mem::size_of::<drm_auth>(),
        4usize,
        concat!("Size of: ", stringify!(drm_auth))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_auth>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_auth))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_auth)).magic as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_auth),
            "::",
            stringify!(magic)
        )
    );
}
impl Clone for drm_auth {
    fn clone(&self) -> Self {
        *self
    }
}
/// DRM_IOCTL_IRQ_BUSID ioctl argument type.
///
/// \sa drmGetInterruptFromBusID().
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_irq_busid {
    /// < IRQ number
    pub irq: libc::c_int,
    /// < bus number
    pub busnum: libc::c_int,
    /// < device number
    pub devnum: libc::c_int,
    /// < function number
    pub funcnum: libc::c_int,
}
#[test]
fn bindgen_test_layout_drm_irq_busid() {
    assert_eq!(
        ::core::mem::size_of::<drm_irq_busid>(),
        16usize,
        concat!("Size of: ", stringify!(drm_irq_busid))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_irq_busid>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_irq_busid))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_irq_busid)).irq as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_irq_busid),
            "::",
            stringify!(irq)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_irq_busid)).busnum as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_irq_busid),
            "::",
            stringify!(busnum)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_irq_busid)).devnum as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_irq_busid),
            "::",
            stringify!(devnum)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_irq_busid)).funcnum as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_irq_busid),
            "::",
            stringify!(funcnum)
        )
    );
}
impl Clone for drm_irq_busid {
    fn clone(&self) -> Self {
        *self
    }
}
pub const drm_vblank_seq_type__DRM_VBLANK_ABSOLUTE: drm_vblank_seq_type = 0;
pub const drm_vblank_seq_type__DRM_VBLANK_RELATIVE: drm_vblank_seq_type = 1;
pub const drm_vblank_seq_type__DRM_VBLANK_HIGH_CRTC_MASK: drm_vblank_seq_type = 62;
pub const drm_vblank_seq_type__DRM_VBLANK_EVENT: drm_vblank_seq_type = 67108864;
pub const drm_vblank_seq_type__DRM_VBLANK_FLIP: drm_vblank_seq_type = 134217728;
pub const drm_vblank_seq_type__DRM_VBLANK_NEXTONMISS: drm_vblank_seq_type = 268435456;
pub const drm_vblank_seq_type__DRM_VBLANK_SECONDARY: drm_vblank_seq_type = 536870912;
pub const drm_vblank_seq_type__DRM_VBLANK_SIGNAL: drm_vblank_seq_type = 1073741824;
pub type drm_vblank_seq_type = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_wait_vblank_request {
    pub type_: drm_vblank_seq_type,
    pub sequence: libc::c_uint,
    pub signal: libc::c_ulong,
}
#[test]
fn bindgen_test_layout_drm_wait_vblank_request() {
    assert_eq!(
        ::core::mem::size_of::<drm_wait_vblank_request>(),
        16usize,
        concat!("Size of: ", stringify!(drm_wait_vblank_request))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_wait_vblank_request>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_wait_vblank_request))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_wait_vblank_request)).type_ as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_wait_vblank_request),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_wait_vblank_request)).sequence as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_wait_vblank_request),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_wait_vblank_request)).signal as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_wait_vblank_request),
            "::",
            stringify!(signal)
        )
    );
}
impl Clone for drm_wait_vblank_request {
    fn clone(&self) -> Self {
        *self
    }
}
impl Default for drm_wait_vblank_request {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drm_wait_vblank_reply {
    pub type_: drm_vblank_seq_type,
    pub sequence: libc::c_uint,
    pub tval_sec: libc::c_long,
    pub tval_usec: libc::c_long,
}
#[test]
fn bindgen_test_layout_drm_wait_vblank_reply() {
    assert_eq!(
        ::core::mem::size_of::<drm_wait_vblank_reply>(),
        24usize,
        concat!("Size of: ", stringify!(drm_wait_vblank_reply))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_wait_vblank_reply>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_wait_vblank_reply))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_wait_vblank_reply)).type_ as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_wait_vblank_reply),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_wait_vblank_reply)).sequence as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_wait_vblank_reply),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_wait_vblank_reply)).tval_sec as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_wait_vblank_reply),
            "::",
            stringify!(tval_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_wait_vblank_reply)).tval_usec as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_wait_vblank_reply),
            "::",
            stringify!(tval_usec)
        )
    );
}
impl Clone for drm_wait_vblank_reply {
    fn clone(&self) -> Self {
        *self
    }
}
impl Default for drm_wait_vblank_reply {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
/// DRM_IOCTL_WAIT_VBLANK ioctl argument type.
///
/// \sa drmWaitVBlank().
#[repr(C)]
#[derive(Copy)]
pub union drm_wait_vblank {
    pub request: drm_wait_vblank_request,
    pub reply: drm_wait_vblank_reply,
    _bindgen_union_align: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_drm_wait_vblank() {
    assert_eq!(
        ::core::mem::size_of::<drm_wait_vblank>(),
        24usize,
        concat!("Size of: ", stringify!(drm_wait_vblank))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_wait_vblank>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_wait_vblank))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_wait_vblank)).request as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_wait_vblank),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_wait_vblank)).reply as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_wait_vblank),
            "::",
            stringify!(reply)
        )
    );
}
impl Clone for drm_wait_vblank {
    fn clone(&self) -> Self {
        *self
    }
}
impl Default for drm_wait_vblank {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
/// DRM_IOCTL_MODESET_CTL ioctl argument type
///
/// \sa drmModesetCtl().
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_modeset_ctl {
    pub crtc: __u32,
    pub cmd: __u32,
}
#[test]
fn bindgen_test_layout_drm_modeset_ctl() {
    assert_eq!(
        ::core::mem::size_of::<drm_modeset_ctl>(),
        8usize,
        concat!("Size of: ", stringify!(drm_modeset_ctl))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_modeset_ctl>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_modeset_ctl))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_modeset_ctl)).crtc as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_modeset_ctl),
            "::",
            stringify!(crtc)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_modeset_ctl)).cmd as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_modeset_ctl),
            "::",
            stringify!(cmd)
        )
    );
}
impl Clone for drm_modeset_ctl {
    fn clone(&self) -> Self {
        *self
    }
}
/// DRM_IOCTL_AGP_ENABLE ioctl argument type.
///
/// \sa drmAgpEnable().
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_agp_mode {
    /// < AGP mode
    pub mode: libc::c_ulong,
}
#[test]
fn bindgen_test_layout_drm_agp_mode() {
    assert_eq!(
        ::core::mem::size_of::<drm_agp_mode>(),
        8usize,
        concat!("Size of: ", stringify!(drm_agp_mode))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_agp_mode>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_agp_mode))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_agp_mode)).mode as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_agp_mode),
            "::",
            stringify!(mode)
        )
    );
}
impl Clone for drm_agp_mode {
    fn clone(&self) -> Self {
        *self
    }
}
/// DRM_IOCTL_AGP_ALLOC and DRM_IOCTL_AGP_FREE ioctls argument type.
///
/// \sa drmAgpAlloc() and drmAgpFree().
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_agp_buffer {
    /// < In bytes -- will round to page boundary
    pub size: libc::c_ulong,
    /// < Used for binding / unbinding
    pub handle: libc::c_ulong,
    /// < Type of memory to allocate
    pub type_: libc::c_ulong,
    /// < Physical used by i810
    pub physical: libc::c_ulong,
}
#[test]
fn bindgen_test_layout_drm_agp_buffer() {
    assert_eq!(
        ::core::mem::size_of::<drm_agp_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(drm_agp_buffer))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_agp_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_agp_buffer))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_agp_buffer)).size as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_agp_buffer),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_agp_buffer)).handle as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_agp_buffer),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_agp_buffer)).type_ as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_agp_buffer),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_agp_buffer)).physical as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_agp_buffer),
            "::",
            stringify!(physical)
        )
    );
}
impl Clone for drm_agp_buffer {
    fn clone(&self) -> Self {
        *self
    }
}
/// DRM_IOCTL_AGP_BIND and DRM_IOCTL_AGP_UNBIND ioctls argument type.
///
/// \sa drmAgpBind() and drmAgpUnbind().
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_agp_binding {
    /// < From drm_agp_buffer
    pub handle: libc::c_ulong,
    /// < In bytes -- will round to page boundary
    pub offset: libc::c_ulong,
}
#[test]
fn bindgen_test_layout_drm_agp_binding() {
    assert_eq!(
        ::core::mem::size_of::<drm_agp_binding>(),
        16usize,
        concat!("Size of: ", stringify!(drm_agp_binding))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_agp_binding>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_agp_binding))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_agp_binding)).handle as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_agp_binding),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_agp_binding)).offset as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_agp_binding),
            "::",
            stringify!(offset)
        )
    );
}
impl Clone for drm_agp_binding {
    fn clone(&self) -> Self {
        *self
    }
}
/// DRM_IOCTL_AGP_INFO ioctl argument type.
///
/// \sa drmAgpVersionMajor(), drmAgpVersionMinor(), drmAgpGetMode(),
/// drmAgpBase(), drmAgpSize(), drmAgpMemoryUsed(), drmAgpMemoryAvail(),
/// drmAgpVendorId() and drmAgpDeviceId().
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_agp_info {
    pub agp_version_major: libc::c_int,
    pub agp_version_minor: libc::c_int,
    pub mode: libc::c_ulong,
    pub aperture_base: libc::c_ulong,
    pub aperture_size: libc::c_ulong,
    pub memory_allowed: libc::c_ulong,
    pub memory_used: libc::c_ulong,
    pub id_vendor: libc::c_ushort,
    pub id_device: libc::c_ushort,
}
#[test]
fn bindgen_test_layout_drm_agp_info() {
    assert_eq!(
        ::core::mem::size_of::<drm_agp_info>(),
        56usize,
        concat!("Size of: ", stringify!(drm_agp_info))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_agp_info>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_agp_info))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_agp_info)).agp_version_major as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_agp_info),
            "::",
            stringify!(agp_version_major)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_agp_info)).agp_version_minor as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_agp_info),
            "::",
            stringify!(agp_version_minor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_agp_info)).mode as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_agp_info),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_agp_info)).aperture_base as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_agp_info),
            "::",
            stringify!(aperture_base)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_agp_info)).aperture_size as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_agp_info),
            "::",
            stringify!(aperture_size)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_agp_info)).memory_allowed as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_agp_info),
            "::",
            stringify!(memory_allowed)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_agp_info)).memory_used as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_agp_info),
            "::",
            stringify!(memory_used)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_agp_info)).id_vendor as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_agp_info),
            "::",
            stringify!(id_vendor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_agp_info)).id_device as *const _ as usize },
        50usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_agp_info),
            "::",
            stringify!(id_device)
        )
    );
}
impl Clone for drm_agp_info {
    fn clone(&self) -> Self {
        *self
    }
}
/// DRM_IOCTL_SG_ALLOC ioctl argument type.
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_scatter_gather {
    /// < In bytes -- will round to page boundary
    pub size: libc::c_ulong,
    /// < Used for mapping / unmapping
    pub handle: libc::c_ulong,
}
#[test]
fn bindgen_test_layout_drm_scatter_gather() {
    assert_eq!(
        ::core::mem::size_of::<drm_scatter_gather>(),
        16usize,
        concat!("Size of: ", stringify!(drm_scatter_gather))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_scatter_gather>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_scatter_gather))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_scatter_gather)).size as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_scatter_gather),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_scatter_gather)).handle as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_scatter_gather),
            "::",
            stringify!(handle)
        )
    );
}
impl Clone for drm_scatter_gather {
    fn clone(&self) -> Self {
        *self
    }
}
/// DRM_IOCTL_SET_VERSION ioctl argument type.
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_set_version {
    pub drm_di_major: libc::c_int,
    pub drm_di_minor: libc::c_int,
    pub drm_dd_major: libc::c_int,
    pub drm_dd_minor: libc::c_int,
}
#[test]
fn bindgen_test_layout_drm_set_version() {
    assert_eq!(
        ::core::mem::size_of::<drm_set_version>(),
        16usize,
        concat!("Size of: ", stringify!(drm_set_version))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_set_version>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_set_version))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_set_version)).drm_di_major as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_set_version),
            "::",
            stringify!(drm_di_major)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_set_version)).drm_di_minor as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_set_version),
            "::",
            stringify!(drm_di_minor)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_set_version)).drm_dd_major as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_set_version),
            "::",
            stringify!(drm_dd_major)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_set_version)).drm_dd_minor as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_set_version),
            "::",
            stringify!(drm_dd_minor)
        )
    );
}
impl Clone for drm_set_version {
    fn clone(&self) -> Self {
        *self
    }
}
/// DRM_IOCTL_GEM_CLOSE ioctl argument type
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_gem_close {
    /// Handle of the object to be closed.
    pub handle: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_drm_gem_close() {
    assert_eq!(
        ::core::mem::size_of::<drm_gem_close>(),
        8usize,
        concat!("Size of: ", stringify!(drm_gem_close))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_gem_close>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_gem_close))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_gem_close)).handle as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_gem_close),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_gem_close)).pad as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_gem_close),
            "::",
            stringify!(pad)
        )
    );
}
impl Clone for drm_gem_close {
    fn clone(&self) -> Self {
        *self
    }
}
/// DRM_IOCTL_GEM_FLINK ioctl argument type
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_gem_flink {
    /// Handle for the object being named
    pub handle: __u32,
    /// Returned global name
    pub name: __u32,
}
#[test]
fn bindgen_test_layout_drm_gem_flink() {
    assert_eq!(
        ::core::mem::size_of::<drm_gem_flink>(),
        8usize,
        concat!("Size of: ", stringify!(drm_gem_flink))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_gem_flink>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_gem_flink))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_gem_flink)).handle as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_gem_flink),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_gem_flink)).name as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_gem_flink),
            "::",
            stringify!(name)
        )
    );
}
impl Clone for drm_gem_flink {
    fn clone(&self) -> Self {
        *self
    }
}
/// DRM_IOCTL_GEM_OPEN ioctl argument type
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_gem_open {
    /// Name of object being opened
    pub name: __u32,
    /// Returned handle for the object
    pub handle: __u32,
    /// Returned size of the object
    pub size: __u64,
}
#[test]
fn bindgen_test_layout_drm_gem_open() {
    assert_eq!(
        ::core::mem::size_of::<drm_gem_open>(),
        16usize,
        concat!("Size of: ", stringify!(drm_gem_open))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_gem_open>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_gem_open))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_gem_open)).name as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_gem_open),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_gem_open)).handle as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_gem_open),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_gem_open)).size as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_gem_open),
            "::",
            stringify!(size)
        )
    );
}
impl Clone for drm_gem_open {
    fn clone(&self) -> Self {
        *self
    }
}
/// DRM_IOCTL_GET_CAP ioctl argument type
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_get_cap {
    pub capability: __u64,
    pub value: __u64,
}
#[test]
fn bindgen_test_layout_drm_get_cap() {
    assert_eq!(
        ::core::mem::size_of::<drm_get_cap>(),
        16usize,
        concat!("Size of: ", stringify!(drm_get_cap))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_get_cap>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_get_cap))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_get_cap)).capability as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_get_cap),
            "::",
            stringify!(capability)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_get_cap)).value as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_get_cap),
            "::",
            stringify!(value)
        )
    );
}
impl Clone for drm_get_cap {
    fn clone(&self) -> Self {
        *self
    }
}
/// DRM_IOCTL_SET_CLIENT_CAP ioctl argument type
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_set_client_cap {
    pub capability: __u64,
    pub value: __u64,
}
#[test]
fn bindgen_test_layout_drm_set_client_cap() {
    assert_eq!(
        ::core::mem::size_of::<drm_set_client_cap>(),
        16usize,
        concat!("Size of: ", stringify!(drm_set_client_cap))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_set_client_cap>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_set_client_cap))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_set_client_cap)).capability as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_set_client_cap),
            "::",
            stringify!(capability)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_set_client_cap)).value as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_set_client_cap),
            "::",
            stringify!(value)
        )
    );
}
impl Clone for drm_set_client_cap {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_prime_handle {
    pub handle: __u32,
    /// Flags.. only applicable for handle->fd
    pub flags: __u32,
    /// Returned dmabuf file descriptor
    pub fd: __s32,
}
#[test]
fn bindgen_test_layout_drm_prime_handle() {
    assert_eq!(
        ::core::mem::size_of::<drm_prime_handle>(),
        12usize,
        concat!("Size of: ", stringify!(drm_prime_handle))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_prime_handle>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_prime_handle))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_prime_handle)).handle as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_prime_handle),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_prime_handle)).flags as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_prime_handle),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_prime_handle)).fd as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_prime_handle),
            "::",
            stringify!(fd)
        )
    );
}
impl Clone for drm_prime_handle {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_syncobj_create {
    pub handle: __u32,
    pub flags: __u32,
}
#[test]
fn bindgen_test_layout_drm_syncobj_create() {
    assert_eq!(
        ::core::mem::size_of::<drm_syncobj_create>(),
        8usize,
        concat!("Size of: ", stringify!(drm_syncobj_create))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_syncobj_create>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_syncobj_create))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_syncobj_create)).handle as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_syncobj_create),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_syncobj_create)).flags as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_syncobj_create),
            "::",
            stringify!(flags)
        )
    );
}
impl Clone for drm_syncobj_create {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_syncobj_destroy {
    pub handle: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_drm_syncobj_destroy() {
    assert_eq!(
        ::core::mem::size_of::<drm_syncobj_destroy>(),
        8usize,
        concat!("Size of: ", stringify!(drm_syncobj_destroy))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_syncobj_destroy>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_syncobj_destroy))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_syncobj_destroy)).handle as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_syncobj_destroy),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_syncobj_destroy)).pad as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_syncobj_destroy),
            "::",
            stringify!(pad)
        )
    );
}
impl Clone for drm_syncobj_destroy {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_syncobj_handle {
    pub handle: __u32,
    pub flags: __u32,
    pub fd: __s32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_drm_syncobj_handle() {
    assert_eq!(
        ::core::mem::size_of::<drm_syncobj_handle>(),
        16usize,
        concat!("Size of: ", stringify!(drm_syncobj_handle))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_syncobj_handle>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_syncobj_handle))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_syncobj_handle)).handle as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_syncobj_handle),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_syncobj_handle)).flags as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_syncobj_handle),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_syncobj_handle)).fd as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_syncobj_handle),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_syncobj_handle)).pad as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_syncobj_handle),
            "::",
            stringify!(pad)
        )
    );
}
impl Clone for drm_syncobj_handle {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_syncobj_wait {
    pub handles: __u64,
    pub timeout_nsec: __s64,
    pub count_handles: __u32,
    pub flags: __u32,
    pub first_signaled: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_drm_syncobj_wait() {
    assert_eq!(
        ::core::mem::size_of::<drm_syncobj_wait>(),
        32usize,
        concat!("Size of: ", stringify!(drm_syncobj_wait))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_syncobj_wait>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_syncobj_wait))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_syncobj_wait)).handles as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_syncobj_wait),
            "::",
            stringify!(handles)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_syncobj_wait)).timeout_nsec as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_syncobj_wait),
            "::",
            stringify!(timeout_nsec)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_syncobj_wait)).count_handles as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_syncobj_wait),
            "::",
            stringify!(count_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_syncobj_wait)).flags as *const _ as usize },
        20usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_syncobj_wait),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_syncobj_wait)).first_signaled as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_syncobj_wait),
            "::",
            stringify!(first_signaled)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_syncobj_wait)).pad as *const _ as usize },
        28usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_syncobj_wait),
            "::",
            stringify!(pad)
        )
    );
}
impl Clone for drm_syncobj_wait {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_syncobj_array {
    pub handles: __u64,
    pub count_handles: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_drm_syncobj_array() {
    assert_eq!(
        ::core::mem::size_of::<drm_syncobj_array>(),
        16usize,
        concat!("Size of: ", stringify!(drm_syncobj_array))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_syncobj_array>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_syncobj_array))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_syncobj_array)).handles as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_syncobj_array),
            "::",
            stringify!(handles)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_syncobj_array)).count_handles as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_syncobj_array),
            "::",
            stringify!(count_handles)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_syncobj_array)).pad as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_syncobj_array),
            "::",
            stringify!(pad)
        )
    );
}
impl Clone for drm_syncobj_array {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_modeinfo {
    pub clock: __u32,
    pub hdisplay: __u16,
    pub hsync_start: __u16,
    pub hsync_end: __u16,
    pub htotal: __u16,
    pub hskew: __u16,
    pub vdisplay: __u16,
    pub vsync_start: __u16,
    pub vsync_end: __u16,
    pub vtotal: __u16,
    pub vscan: __u16,
    pub vrefresh: __u32,
    pub flags: __u32,
    pub type_: __u32,
    pub name: [libc::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_drm_mode_modeinfo() {
    assert_eq!(
        ::core::mem::size_of::<drm_mode_modeinfo>(),
        68usize,
        concat!("Size of: ", stringify!(drm_mode_modeinfo))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_mode_modeinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_mode_modeinfo))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_modeinfo)).clock as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_modeinfo),
            "::",
            stringify!(clock)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_modeinfo)).hdisplay as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_modeinfo),
            "::",
            stringify!(hdisplay)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_modeinfo)).hsync_start as *const _ as usize },
        6usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_modeinfo),
            "::",
            stringify!(hsync_start)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_modeinfo)).hsync_end as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_modeinfo),
            "::",
            stringify!(hsync_end)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_modeinfo)).htotal as *const _ as usize },
        10usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_modeinfo),
            "::",
            stringify!(htotal)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_modeinfo)).hskew as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_modeinfo),
            "::",
            stringify!(hskew)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_modeinfo)).vdisplay as *const _ as usize },
        14usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_modeinfo),
            "::",
            stringify!(vdisplay)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_modeinfo)).vsync_start as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_modeinfo),
            "::",
            stringify!(vsync_start)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_modeinfo)).vsync_end as *const _ as usize },
        18usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_modeinfo),
            "::",
            stringify!(vsync_end)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_modeinfo)).vtotal as *const _ as usize },
        20usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_modeinfo),
            "::",
            stringify!(vtotal)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_modeinfo)).vscan as *const _ as usize },
        22usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_modeinfo),
            "::",
            stringify!(vscan)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_modeinfo)).vrefresh as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_modeinfo),
            "::",
            stringify!(vrefresh)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_modeinfo)).flags as *const _ as usize },
        28usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_modeinfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_modeinfo)).type_ as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_modeinfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_modeinfo)).name as *const _ as usize },
        36usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_modeinfo),
            "::",
            stringify!(name)
        )
    );
}
impl Clone for drm_mode_modeinfo {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_card_res {
    pub fb_id_ptr: __u64,
    pub crtc_id_ptr: __u64,
    pub connector_id_ptr: __u64,
    pub encoder_id_ptr: __u64,
    pub count_fbs: __u32,
    pub count_crtcs: __u32,
    pub count_connectors: __u32,
    pub count_encoders: __u32,
    pub min_width: __u32,
    pub max_width: __u32,
    pub min_height: __u32,
    pub max_height: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_card_res() {
    assert_eq!(
        ::core::mem::size_of::<drm_mode_card_res>(),
        64usize,
        concat!("Size of: ", stringify!(drm_mode_card_res))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_mode_card_res>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_card_res))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_card_res)).fb_id_ptr as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_card_res),
            "::",
            stringify!(fb_id_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_card_res)).crtc_id_ptr as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_card_res),
            "::",
            stringify!(crtc_id_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_card_res)).connector_id_ptr as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_card_res),
            "::",
            stringify!(connector_id_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_card_res)).encoder_id_ptr as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_card_res),
            "::",
            stringify!(encoder_id_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_card_res)).count_fbs as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_card_res),
            "::",
            stringify!(count_fbs)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_card_res)).count_crtcs as *const _ as usize },
        36usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_card_res),
            "::",
            stringify!(count_crtcs)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_card_res)).count_connectors as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_card_res),
            "::",
            stringify!(count_connectors)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_card_res)).count_encoders as *const _ as usize },
        44usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_card_res),
            "::",
            stringify!(count_encoders)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_card_res)).min_width as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_card_res),
            "::",
            stringify!(min_width)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_card_res)).max_width as *const _ as usize },
        52usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_card_res),
            "::",
            stringify!(max_width)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_card_res)).min_height as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_card_res),
            "::",
            stringify!(min_height)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_card_res)).max_height as *const _ as usize },
        60usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_card_res),
            "::",
            stringify!(max_height)
        )
    );
}
impl Clone for drm_mode_card_res {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_crtc {
    pub set_connectors_ptr: __u64,
    pub count_connectors: __u32,
    /// < Id
    pub crtc_id: __u32,
    /// < Id of framebuffer
    pub fb_id: __u32,
    /// < x Position on the framebuffer
    pub x: __u32,
    /// < y Position on the framebuffer
    pub y: __u32,
    pub gamma_size: __u32,
    pub mode_valid: __u32,
    pub mode: drm_mode_modeinfo,
}
#[test]
fn bindgen_test_layout_drm_mode_crtc() {
    assert_eq!(
        ::core::mem::size_of::<drm_mode_crtc>(),
        104usize,
        concat!("Size of: ", stringify!(drm_mode_crtc))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_mode_crtc>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_crtc))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_crtc)).set_connectors_ptr as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_crtc),
            "::",
            stringify!(set_connectors_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_crtc)).count_connectors as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_crtc),
            "::",
            stringify!(count_connectors)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_crtc)).crtc_id as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_crtc),
            "::",
            stringify!(crtc_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_crtc)).fb_id as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_crtc),
            "::",
            stringify!(fb_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_crtc)).x as *const _ as usize },
        20usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_crtc),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_crtc)).y as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_crtc),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_crtc)).gamma_size as *const _ as usize },
        28usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_crtc),
            "::",
            stringify!(gamma_size)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_crtc)).mode_valid as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_crtc),
            "::",
            stringify!(mode_valid)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_crtc)).mode as *const _ as usize },
        36usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_crtc),
            "::",
            stringify!(mode)
        )
    );
}
impl Clone for drm_mode_crtc {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_set_plane {
    pub plane_id: __u32,
    pub crtc_id: __u32,
    pub fb_id: __u32,
    pub flags: __u32,
    pub crtc_x: __s32,
    pub crtc_y: __s32,
    pub crtc_w: __u32,
    pub crtc_h: __u32,
    pub src_x: __u32,
    pub src_y: __u32,
    pub src_h: __u32,
    pub src_w: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_set_plane() {
    assert_eq!(
        ::core::mem::size_of::<drm_mode_set_plane>(),
        48usize,
        concat!("Size of: ", stringify!(drm_mode_set_plane))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_mode_set_plane>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_mode_set_plane))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_set_plane)).plane_id as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_set_plane),
            "::",
            stringify!(plane_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_set_plane)).crtc_id as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_set_plane),
            "::",
            stringify!(crtc_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_set_plane)).fb_id as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_set_plane),
            "::",
            stringify!(fb_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_set_plane)).flags as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_set_plane),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_set_plane)).crtc_x as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_set_plane),
            "::",
            stringify!(crtc_x)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_set_plane)).crtc_y as *const _ as usize },
        20usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_set_plane),
            "::",
            stringify!(crtc_y)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_set_plane)).crtc_w as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_set_plane),
            "::",
            stringify!(crtc_w)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_set_plane)).crtc_h as *const _ as usize },
        28usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_set_plane),
            "::",
            stringify!(crtc_h)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_set_plane)).src_x as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_set_plane),
            "::",
            stringify!(src_x)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_set_plane)).src_y as *const _ as usize },
        36usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_set_plane),
            "::",
            stringify!(src_y)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_set_plane)).src_h as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_set_plane),
            "::",
            stringify!(src_h)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_set_plane)).src_w as *const _ as usize },
        44usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_set_plane),
            "::",
            stringify!(src_w)
        )
    );
}
impl Clone for drm_mode_set_plane {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_get_plane {
    pub plane_id: __u32,
    pub crtc_id: __u32,
    pub fb_id: __u32,
    pub possible_crtcs: __u32,
    pub gamma_size: __u32,
    pub count_format_types: __u32,
    pub format_type_ptr: __u64,
}
#[test]
fn bindgen_test_layout_drm_mode_get_plane() {
    assert_eq!(
        ::core::mem::size_of::<drm_mode_get_plane>(),
        32usize,
        concat!("Size of: ", stringify!(drm_mode_get_plane))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_mode_get_plane>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_get_plane))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_plane)).plane_id as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_plane),
            "::",
            stringify!(plane_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_plane)).crtc_id as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_plane),
            "::",
            stringify!(crtc_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_plane)).fb_id as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_plane),
            "::",
            stringify!(fb_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_plane)).possible_crtcs as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_plane),
            "::",
            stringify!(possible_crtcs)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_plane)).gamma_size as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_plane),
            "::",
            stringify!(gamma_size)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_plane)).count_format_types as *const _ as usize },
        20usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_plane),
            "::",
            stringify!(count_format_types)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_plane)).format_type_ptr as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_plane),
            "::",
            stringify!(format_type_ptr)
        )
    );
}
impl Clone for drm_mode_get_plane {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_get_plane_res {
    pub plane_id_ptr: __u64,
    pub count_planes: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_get_plane_res() {
    assert_eq!(
        ::core::mem::size_of::<drm_mode_get_plane_res>(),
        16usize,
        concat!("Size of: ", stringify!(drm_mode_get_plane_res))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_mode_get_plane_res>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_get_plane_res))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_plane_res)).plane_id_ptr as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_plane_res),
            "::",
            stringify!(plane_id_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_plane_res)).count_planes as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_plane_res),
            "::",
            stringify!(count_planes)
        )
    );
}
impl Clone for drm_mode_get_plane_res {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_get_encoder {
    pub encoder_id: __u32,
    pub encoder_type: __u32,
    /// < Id of crtc
    pub crtc_id: __u32,
    pub possible_crtcs: __u32,
    pub possible_clones: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_get_encoder() {
    assert_eq!(
        ::core::mem::size_of::<drm_mode_get_encoder>(),
        20usize,
        concat!("Size of: ", stringify!(drm_mode_get_encoder))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_mode_get_encoder>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_mode_get_encoder))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_encoder)).encoder_id as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_encoder),
            "::",
            stringify!(encoder_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_encoder)).encoder_type as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_encoder),
            "::",
            stringify!(encoder_type)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_encoder)).crtc_id as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_encoder),
            "::",
            stringify!(crtc_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_encoder)).possible_crtcs as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_encoder),
            "::",
            stringify!(possible_crtcs)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_encoder)).possible_clones as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_encoder),
            "::",
            stringify!(possible_clones)
        )
    );
}
impl Clone for drm_mode_get_encoder {
    fn clone(&self) -> Self {
        *self
    }
}
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_Automatic: drm_mode_subconnector = 0;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_Unknown: drm_mode_subconnector = 0;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_DVID: drm_mode_subconnector = 3;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_DVIA: drm_mode_subconnector = 4;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_Composite: drm_mode_subconnector = 5;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_SVIDEO: drm_mode_subconnector = 6;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_Component: drm_mode_subconnector = 8;
pub const drm_mode_subconnector_DRM_MODE_SUBCONNECTOR_SCART: drm_mode_subconnector = 9;
pub type drm_mode_subconnector = libc::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_get_connector {
    pub encoders_ptr: __u64,
    pub modes_ptr: __u64,
    pub props_ptr: __u64,
    pub prop_values_ptr: __u64,
    pub count_modes: __u32,
    pub count_props: __u32,
    pub count_encoders: __u32,
    /// < Current Encoder
    pub encoder_id: __u32,
    /// < Id
    pub connector_id: __u32,
    pub connector_type: __u32,
    pub connector_type_id: __u32,
    pub connection: __u32,
    /// < width in millimeters
    pub mm_width: __u32,
    /// < height in millimeters
    pub mm_height: __u32,
    pub subpixel: __u32,
    pub pad: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_get_connector() {
    assert_eq!(
        ::core::mem::size_of::<drm_mode_get_connector>(),
        80usize,
        concat!("Size of: ", stringify!(drm_mode_get_connector))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_mode_get_connector>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_get_connector))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_connector)).encoders_ptr as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(encoders_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_connector)).modes_ptr as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(modes_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_connector)).props_ptr as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(props_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_connector)).prop_values_ptr as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(prop_values_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_connector)).count_modes as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(count_modes)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_connector)).count_props as *const _ as usize },
        36usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(count_props)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_connector)).count_encoders as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(count_encoders)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_connector)).encoder_id as *const _ as usize },
        44usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(encoder_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_connector)).connector_id as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(connector_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_connector)).connector_type as *const _ as usize },
        52usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(connector_type)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_connector)).connector_type_id as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(connector_type_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_connector)).connection as *const _ as usize },
        60usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(connection)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_connector)).mm_width as *const _ as usize },
        64usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(mm_width)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_connector)).mm_height as *const _ as usize },
        68usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(mm_height)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_connector)).subpixel as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(subpixel)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_connector)).pad as *const _ as usize },
        76usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_connector),
            "::",
            stringify!(pad)
        )
    );
}
impl Clone for drm_mode_get_connector {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_property_enum {
    pub value: __u64,
    pub name: [libc::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_drm_mode_property_enum() {
    assert_eq!(
        ::core::mem::size_of::<drm_mode_property_enum>(),
        40usize,
        concat!("Size of: ", stringify!(drm_mode_property_enum))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_mode_property_enum>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_property_enum))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_property_enum)).value as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_property_enum),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_property_enum)).name as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_property_enum),
            "::",
            stringify!(name)
        )
    );
}
impl Clone for drm_mode_property_enum {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_get_property {
    pub values_ptr: __u64,
    pub enum_blob_ptr: __u64,
    pub prop_id: __u32,
    pub flags: __u32,
    pub name: [libc::c_char; 32usize],
    pub count_values: __u32,
    pub count_enum_blobs: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_get_property() {
    assert_eq!(
        ::core::mem::size_of::<drm_mode_get_property>(),
        64usize,
        concat!("Size of: ", stringify!(drm_mode_get_property))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_mode_get_property>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_get_property))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_property)).values_ptr as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_property),
            "::",
            stringify!(values_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_property)).enum_blob_ptr as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_property),
            "::",
            stringify!(enum_blob_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_property)).prop_id as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_property),
            "::",
            stringify!(prop_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_property)).flags as *const _ as usize },
        20usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_property),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_property)).name as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_property),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_property)).count_values as *const _ as usize },
        56usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_property),
            "::",
            stringify!(count_values)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_property)).count_enum_blobs as *const _ as usize },
        60usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_property),
            "::",
            stringify!(count_enum_blobs)
        )
    );
}
impl Clone for drm_mode_get_property {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_connector_set_property {
    pub value: __u64,
    pub prop_id: __u32,
    pub connector_id: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_connector_set_property() {
    assert_eq!(
        ::core::mem::size_of::<drm_mode_connector_set_property>(),
        16usize,
        concat!("Size of: ", stringify!(drm_mode_connector_set_property))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_mode_connector_set_property>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_connector_set_property))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_connector_set_property)).value as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_connector_set_property),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_connector_set_property)).prop_id as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_connector_set_property),
            "::",
            stringify!(prop_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const drm_mode_connector_set_property)).connector_id as *const _ as usize
        },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_connector_set_property),
            "::",
            stringify!(connector_id)
        )
    );
}
impl Clone for drm_mode_connector_set_property {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_obj_get_properties {
    pub props_ptr: __u64,
    pub prop_values_ptr: __u64,
    pub count_props: __u32,
    pub obj_id: __u32,
    pub obj_type: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_obj_get_properties() {
    assert_eq!(
        ::core::mem::size_of::<drm_mode_obj_get_properties>(),
        32usize,
        concat!("Size of: ", stringify!(drm_mode_obj_get_properties))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_mode_obj_get_properties>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_obj_get_properties))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_obj_get_properties)).props_ptr as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_obj_get_properties),
            "::",
            stringify!(props_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const drm_mode_obj_get_properties)).prop_values_ptr as *const _ as usize
        },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_obj_get_properties),
            "::",
            stringify!(prop_values_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_obj_get_properties)).count_props as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_obj_get_properties),
            "::",
            stringify!(count_props)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_obj_get_properties)).obj_id as *const _ as usize },
        20usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_obj_get_properties),
            "::",
            stringify!(obj_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_obj_get_properties)).obj_type as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_obj_get_properties),
            "::",
            stringify!(obj_type)
        )
    );
}
impl Clone for drm_mode_obj_get_properties {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_obj_set_property {
    pub value: __u64,
    pub prop_id: __u32,
    pub obj_id: __u32,
    pub obj_type: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_obj_set_property() {
    assert_eq!(
        ::core::mem::size_of::<drm_mode_obj_set_property>(),
        24usize,
        concat!("Size of: ", stringify!(drm_mode_obj_set_property))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_mode_obj_set_property>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_obj_set_property))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_obj_set_property)).value as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_obj_set_property),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_obj_set_property)).prop_id as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_obj_set_property),
            "::",
            stringify!(prop_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_obj_set_property)).obj_id as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_obj_set_property),
            "::",
            stringify!(obj_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_obj_set_property)).obj_type as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_obj_set_property),
            "::",
            stringify!(obj_type)
        )
    );
}
impl Clone for drm_mode_obj_set_property {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_get_blob {
    pub blob_id: __u32,
    pub length: __u32,
    pub data: __u64,
}
#[test]
fn bindgen_test_layout_drm_mode_get_blob() {
    assert_eq!(
        ::core::mem::size_of::<drm_mode_get_blob>(),
        16usize,
        concat!("Size of: ", stringify!(drm_mode_get_blob))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_mode_get_blob>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_get_blob))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_blob)).blob_id as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_blob),
            "::",
            stringify!(blob_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_blob)).length as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_blob),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_get_blob)).data as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_get_blob),
            "::",
            stringify!(data)
        )
    );
}
impl Clone for drm_mode_get_blob {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_fb_cmd {
    pub fb_id: __u32,
    pub width: __u32,
    pub height: __u32,
    pub pitch: __u32,
    pub bpp: __u32,
    pub depth: __u32,
    pub handle: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_fb_cmd() {
    assert_eq!(
        ::core::mem::size_of::<drm_mode_fb_cmd>(),
        28usize,
        concat!("Size of: ", stringify!(drm_mode_fb_cmd))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_mode_fb_cmd>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_mode_fb_cmd))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_fb_cmd)).fb_id as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_fb_cmd),
            "::",
            stringify!(fb_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_fb_cmd)).width as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_fb_cmd),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_fb_cmd)).height as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_fb_cmd),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_fb_cmd)).pitch as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_fb_cmd),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_fb_cmd)).bpp as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_fb_cmd),
            "::",
            stringify!(bpp)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_fb_cmd)).depth as *const _ as usize },
        20usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_fb_cmd),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_fb_cmd)).handle as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_fb_cmd),
            "::",
            stringify!(handle)
        )
    );
}
impl Clone for drm_mode_fb_cmd {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_fb_cmd2 {
    pub fb_id: __u32,
    pub width: __u32,
    pub height: __u32,
    pub pixel_format: __u32,
    pub flags: __u32,
    pub handles: [__u32; 4usize],
    pub pitches: [__u32; 4usize],
    pub offsets: [__u32; 4usize],
    pub modifier: [__u64; 4usize],
}
#[test]
fn bindgen_test_layout_drm_mode_fb_cmd2() {
    assert_eq!(
        ::core::mem::size_of::<drm_mode_fb_cmd2>(),
        104usize,
        concat!("Size of: ", stringify!(drm_mode_fb_cmd2))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_mode_fb_cmd2>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_fb_cmd2))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_fb_cmd2)).fb_id as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_fb_cmd2),
            "::",
            stringify!(fb_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_fb_cmd2)).width as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_fb_cmd2),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_fb_cmd2)).height as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_fb_cmd2),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_fb_cmd2)).pixel_format as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_fb_cmd2),
            "::",
            stringify!(pixel_format)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_fb_cmd2)).flags as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_fb_cmd2),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_fb_cmd2)).handles as *const _ as usize },
        20usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_fb_cmd2),
            "::",
            stringify!(handles)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_fb_cmd2)).pitches as *const _ as usize },
        36usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_fb_cmd2),
            "::",
            stringify!(pitches)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_fb_cmd2)).offsets as *const _ as usize },
        52usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_fb_cmd2),
            "::",
            stringify!(offsets)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_fb_cmd2)).modifier as *const _ as usize },
        72usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_fb_cmd2),
            "::",
            stringify!(modifier)
        )
    );
}
impl Clone for drm_mode_fb_cmd2 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_fb_dirty_cmd {
    pub fb_id: __u32,
    pub flags: __u32,
    pub color: __u32,
    pub num_clips: __u32,
    pub clips_ptr: __u64,
}
#[test]
fn bindgen_test_layout_drm_mode_fb_dirty_cmd() {
    assert_eq!(
        ::core::mem::size_of::<drm_mode_fb_dirty_cmd>(),
        24usize,
        concat!("Size of: ", stringify!(drm_mode_fb_dirty_cmd))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_mode_fb_dirty_cmd>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_fb_dirty_cmd))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_fb_dirty_cmd)).fb_id as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_fb_dirty_cmd),
            "::",
            stringify!(fb_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_fb_dirty_cmd)).flags as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_fb_dirty_cmd),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_fb_dirty_cmd)).color as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_fb_dirty_cmd),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_fb_dirty_cmd)).num_clips as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_fb_dirty_cmd),
            "::",
            stringify!(num_clips)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_fb_dirty_cmd)).clips_ptr as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_fb_dirty_cmd),
            "::",
            stringify!(clips_ptr)
        )
    );
}
impl Clone for drm_mode_fb_dirty_cmd {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_mode_cmd {
    pub connector_id: __u32,
    pub mode: drm_mode_modeinfo,
}
#[test]
fn bindgen_test_layout_drm_mode_mode_cmd() {
    assert_eq!(
        ::core::mem::size_of::<drm_mode_mode_cmd>(),
        72usize,
        concat!("Size of: ", stringify!(drm_mode_mode_cmd))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_mode_mode_cmd>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_mode_mode_cmd))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_mode_cmd)).connector_id as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_mode_cmd),
            "::",
            stringify!(connector_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_mode_cmd)).mode as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_mode_cmd),
            "::",
            stringify!(mode)
        )
    );
}
impl Clone for drm_mode_mode_cmd {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_cursor {
    pub flags: __u32,
    pub crtc_id: __u32,
    pub x: __s32,
    pub y: __s32,
    pub width: __u32,
    pub height: __u32,
    pub handle: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_cursor() {
    assert_eq!(
        ::core::mem::size_of::<drm_mode_cursor>(),
        28usize,
        concat!("Size of: ", stringify!(drm_mode_cursor))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_mode_cursor>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_mode_cursor))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_cursor)).flags as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_cursor),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_cursor)).crtc_id as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_cursor),
            "::",
            stringify!(crtc_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_cursor)).x as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_cursor),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_cursor)).y as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_cursor),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_cursor)).width as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_cursor),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_cursor)).height as *const _ as usize },
        20usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_cursor),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_cursor)).handle as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_cursor),
            "::",
            stringify!(handle)
        )
    );
}
impl Clone for drm_mode_cursor {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_cursor2 {
    pub flags: __u32,
    pub crtc_id: __u32,
    pub x: __s32,
    pub y: __s32,
    pub width: __u32,
    pub height: __u32,
    pub handle: __u32,
    pub hot_x: __s32,
    pub hot_y: __s32,
}
#[test]
fn bindgen_test_layout_drm_mode_cursor2() {
    assert_eq!(
        ::core::mem::size_of::<drm_mode_cursor2>(),
        36usize,
        concat!("Size of: ", stringify!(drm_mode_cursor2))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_mode_cursor2>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_mode_cursor2))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_cursor2)).flags as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_cursor2),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_cursor2)).crtc_id as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_cursor2),
            "::",
            stringify!(crtc_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_cursor2)).x as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_cursor2),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_cursor2)).y as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_cursor2),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_cursor2)).width as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_cursor2),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_cursor2)).height as *const _ as usize },
        20usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_cursor2),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_cursor2)).handle as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_cursor2),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_cursor2)).hot_x as *const _ as usize },
        28usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_cursor2),
            "::",
            stringify!(hot_x)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_cursor2)).hot_y as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_cursor2),
            "::",
            stringify!(hot_y)
        )
    );
}
impl Clone for drm_mode_cursor2 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_crtc_lut {
    pub crtc_id: __u32,
    pub gamma_size: __u32,
    pub red: __u64,
    pub green: __u64,
    pub blue: __u64,
}
#[test]
fn bindgen_test_layout_drm_mode_crtc_lut() {
    assert_eq!(
        ::core::mem::size_of::<drm_mode_crtc_lut>(),
        32usize,
        concat!("Size of: ", stringify!(drm_mode_crtc_lut))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_mode_crtc_lut>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_crtc_lut))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_crtc_lut)).crtc_id as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_crtc_lut),
            "::",
            stringify!(crtc_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_crtc_lut)).gamma_size as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_crtc_lut),
            "::",
            stringify!(gamma_size)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_crtc_lut)).red as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_crtc_lut),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_crtc_lut)).green as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_crtc_lut),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_crtc_lut)).blue as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_crtc_lut),
            "::",
            stringify!(blue)
        )
    );
}
impl Clone for drm_mode_crtc_lut {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_color_ctm {
    pub matrix: [__s64; 9usize],
}
#[test]
fn bindgen_test_layout_drm_color_ctm() {
    assert_eq!(
        ::core::mem::size_of::<drm_color_ctm>(),
        72usize,
        concat!("Size of: ", stringify!(drm_color_ctm))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_color_ctm>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_color_ctm))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_color_ctm)).matrix as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_color_ctm),
            "::",
            stringify!(matrix)
        )
    );
}
impl Clone for drm_color_ctm {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_color_lut {
    pub red: __u16,
    pub green: __u16,
    pub blue: __u16,
    pub reserved: __u16,
}
#[test]
fn bindgen_test_layout_drm_color_lut() {
    assert_eq!(
        ::core::mem::size_of::<drm_color_lut>(),
        8usize,
        concat!("Size of: ", stringify!(drm_color_lut))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_color_lut>(),
        2usize,
        concat!("Alignment of ", stringify!(drm_color_lut))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_color_lut)).red as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_color_lut),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_color_lut)).green as *const _ as usize },
        2usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_color_lut),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_color_lut)).blue as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_color_lut),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_color_lut)).reserved as *const _ as usize },
        6usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_color_lut),
            "::",
            stringify!(reserved)
        )
    );
}
impl Clone for drm_color_lut {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_crtc_page_flip {
    pub crtc_id: __u32,
    pub fb_id: __u32,
    pub flags: __u32,
    pub reserved: __u32,
    pub user_data: __u64,
}
#[test]
fn bindgen_test_layout_drm_mode_crtc_page_flip() {
    assert_eq!(
        ::core::mem::size_of::<drm_mode_crtc_page_flip>(),
        24usize,
        concat!("Size of: ", stringify!(drm_mode_crtc_page_flip))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_mode_crtc_page_flip>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_crtc_page_flip))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_crtc_page_flip)).crtc_id as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_crtc_page_flip),
            "::",
            stringify!(crtc_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_crtc_page_flip)).fb_id as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_crtc_page_flip),
            "::",
            stringify!(fb_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_crtc_page_flip)).flags as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_crtc_page_flip),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_crtc_page_flip)).reserved as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_crtc_page_flip),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_crtc_page_flip)).user_data as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_crtc_page_flip),
            "::",
            stringify!(user_data)
        )
    );
}
impl Clone for drm_mode_crtc_page_flip {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_crtc_page_flip_target {
    pub crtc_id: __u32,
    pub fb_id: __u32,
    pub flags: __u32,
    pub sequence: __u32,
    pub user_data: __u64,
}
#[test]
fn bindgen_test_layout_drm_mode_crtc_page_flip_target() {
    assert_eq!(
        ::core::mem::size_of::<drm_mode_crtc_page_flip_target>(),
        24usize,
        concat!("Size of: ", stringify!(drm_mode_crtc_page_flip_target))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_mode_crtc_page_flip_target>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_crtc_page_flip_target))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_crtc_page_flip_target)).crtc_id as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_crtc_page_flip_target),
            "::",
            stringify!(crtc_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_crtc_page_flip_target)).fb_id as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_crtc_page_flip_target),
            "::",
            stringify!(fb_id)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_crtc_page_flip_target)).flags as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_crtc_page_flip_target),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_crtc_page_flip_target)).sequence as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_crtc_page_flip_target),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_crtc_page_flip_target)).user_data as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_crtc_page_flip_target),
            "::",
            stringify!(user_data)
        )
    );
}
impl Clone for drm_mode_crtc_page_flip_target {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_create_dumb {
    pub height: __u32,
    pub width: __u32,
    pub bpp: __u32,
    pub flags: __u32,
    pub handle: __u32,
    pub pitch: __u32,
    pub size: __u64,
}
#[test]
fn bindgen_test_layout_drm_mode_create_dumb() {
    assert_eq!(
        ::core::mem::size_of::<drm_mode_create_dumb>(),
        32usize,
        concat!("Size of: ", stringify!(drm_mode_create_dumb))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_mode_create_dumb>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_create_dumb))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_create_dumb)).height as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_create_dumb),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_create_dumb)).width as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_create_dumb),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_create_dumb)).bpp as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_create_dumb),
            "::",
            stringify!(bpp)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_create_dumb)).flags as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_create_dumb),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_create_dumb)).handle as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_create_dumb),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_create_dumb)).pitch as *const _ as usize },
        20usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_create_dumb),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_create_dumb)).size as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_create_dumb),
            "::",
            stringify!(size)
        )
    );
}
impl Clone for drm_mode_create_dumb {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_map_dumb {
    /// Handle for the object being mapped.
    pub handle: __u32,
    pub pad: __u32,
    /// Fake offset to use for subsequent mmap call
    ///
    /// This is a fixed-size type for 32/64 compatibility.
    pub offset: __u64,
}
#[test]
fn bindgen_test_layout_drm_mode_map_dumb() {
    assert_eq!(
        ::core::mem::size_of::<drm_mode_map_dumb>(),
        16usize,
        concat!("Size of: ", stringify!(drm_mode_map_dumb))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_mode_map_dumb>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_map_dumb))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_map_dumb)).handle as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_map_dumb),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_map_dumb)).pad as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_map_dumb),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_map_dumb)).offset as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_map_dumb),
            "::",
            stringify!(offset)
        )
    );
}
impl Clone for drm_mode_map_dumb {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_destroy_dumb {
    pub handle: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_destroy_dumb() {
    assert_eq!(
        ::core::mem::size_of::<drm_mode_destroy_dumb>(),
        4usize,
        concat!("Size of: ", stringify!(drm_mode_destroy_dumb))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_mode_destroy_dumb>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_mode_destroy_dumb))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_destroy_dumb)).handle as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_destroy_dumb),
            "::",
            stringify!(handle)
        )
    );
}
impl Clone for drm_mode_destroy_dumb {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_atomic {
    pub flags: __u32,
    pub count_objs: __u32,
    pub objs_ptr: __u64,
    pub count_props_ptr: __u64,
    pub props_ptr: __u64,
    pub prop_values_ptr: __u64,
    pub reserved: __u64,
    pub user_data: __u64,
}
#[test]
fn bindgen_test_layout_drm_mode_atomic() {
    assert_eq!(
        ::core::mem::size_of::<drm_mode_atomic>(),
        56usize,
        concat!("Size of: ", stringify!(drm_mode_atomic))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_mode_atomic>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_atomic))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_atomic)).flags as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_atomic),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_atomic)).count_objs as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_atomic),
            "::",
            stringify!(count_objs)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_atomic)).objs_ptr as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_atomic),
            "::",
            stringify!(objs_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_atomic)).count_props_ptr as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_atomic),
            "::",
            stringify!(count_props_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_atomic)).props_ptr as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_atomic),
            "::",
            stringify!(props_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_atomic)).prop_values_ptr as *const _ as usize },
        32usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_atomic),
            "::",
            stringify!(prop_values_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_atomic)).reserved as *const _ as usize },
        40usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_atomic),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_atomic)).user_data as *const _ as usize },
        48usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_atomic),
            "::",
            stringify!(user_data)
        )
    );
}
impl Clone for drm_mode_atomic {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_format_modifier_blob {
    pub version: __u32,
    pub flags: __u32,
    pub count_formats: __u32,
    pub formats_offset: __u32,
    pub count_modifiers: __u32,
    pub modifiers_offset: __u32,
}
#[test]
fn bindgen_test_layout_drm_format_modifier_blob() {
    assert_eq!(
        ::core::mem::size_of::<drm_format_modifier_blob>(),
        24usize,
        concat!("Size of: ", stringify!(drm_format_modifier_blob))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_format_modifier_blob>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_format_modifier_blob))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_format_modifier_blob)).version as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_format_modifier_blob),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_format_modifier_blob)).flags as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_format_modifier_blob),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_format_modifier_blob)).count_formats as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_format_modifier_blob),
            "::",
            stringify!(count_formats)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_format_modifier_blob)).formats_offset as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_format_modifier_blob),
            "::",
            stringify!(formats_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_format_modifier_blob)).count_modifiers as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_format_modifier_blob),
            "::",
            stringify!(count_modifiers)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_format_modifier_blob)).modifiers_offset as *const _ as usize },
        20usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_format_modifier_blob),
            "::",
            stringify!(modifiers_offset)
        )
    );
}
impl Clone for drm_format_modifier_blob {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_format_modifier {
    pub formats: __u64,
    pub offset: __u32,
    pub pad: __u32,
    pub modifier: __u64,
}
#[test]
fn bindgen_test_layout_drm_format_modifier() {
    assert_eq!(
        ::core::mem::size_of::<drm_format_modifier>(),
        24usize,
        concat!("Size of: ", stringify!(drm_format_modifier))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_format_modifier>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_format_modifier))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_format_modifier)).formats as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_format_modifier),
            "::",
            stringify!(formats)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_format_modifier)).offset as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_format_modifier),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_format_modifier)).pad as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_format_modifier),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_format_modifier)).modifier as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_format_modifier),
            "::",
            stringify!(modifier)
        )
    );
}
impl Clone for drm_format_modifier {
    fn clone(&self) -> Self {
        *self
    }
}
/// Create a new 'blob' data property, copying length bytes from data pointer,
/// and returning new blob ID.
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_create_blob {
    /// Pointer to data to copy.
    pub data: __u64,
    /// Length of data to copy.
    pub length: __u32,
    /// Return: new property ID.
    pub blob_id: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_create_blob() {
    assert_eq!(
        ::core::mem::size_of::<drm_mode_create_blob>(),
        16usize,
        concat!("Size of: ", stringify!(drm_mode_create_blob))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_mode_create_blob>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_mode_create_blob))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_create_blob)).data as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_create_blob),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_create_blob)).length as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_create_blob),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_create_blob)).blob_id as *const _ as usize },
        12usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_create_blob),
            "::",
            stringify!(blob_id)
        )
    );
}
impl Clone for drm_mode_create_blob {
    fn clone(&self) -> Self {
        *self
    }
}
/// Destroy a user-created blob property.
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_mode_destroy_blob {
    pub blob_id: __u32,
}
#[test]
fn bindgen_test_layout_drm_mode_destroy_blob() {
    assert_eq!(
        ::core::mem::size_of::<drm_mode_destroy_blob>(),
        4usize,
        concat!("Size of: ", stringify!(drm_mode_destroy_blob))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_mode_destroy_blob>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_mode_destroy_blob))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_mode_destroy_blob)).blob_id as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_mode_destroy_blob),
            "::",
            stringify!(blob_id)
        )
    );
}
impl Clone for drm_mode_destroy_blob {
    fn clone(&self) -> Self {
        *self
    }
}
/// Header for events written back to userspace on the drm fd.  The
/// type defines the type of event, the length specifies the total
/// length of the event (including the header), and user_data is
/// typically a 64 bit value passed with the ioctl that triggered the
/// event.  A read on the drm fd will always only return complete
/// events, that is, if for example the read buffer is 100 bytes, and
/// there are two 64 byte events pending, only one will be returned.
///
/// Event types 0 - 0x7fffffff are generic drm events, 0x80000000 and
/// up are chipset specific.
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_event {
    pub type_: __u32,
    pub length: __u32,
}
#[test]
fn bindgen_test_layout_drm_event() {
    assert_eq!(
        ::core::mem::size_of::<drm_event>(),
        8usize,
        concat!("Size of: ", stringify!(drm_event))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_event>(),
        4usize,
        concat!("Alignment of ", stringify!(drm_event))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_event)).type_ as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_event),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_event)).length as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_event),
            "::",
            stringify!(length)
        )
    );
}
impl Clone for drm_event {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drm_event_vblank {
    pub base: drm_event,
    pub user_data: __u64,
    pub tv_sec: __u32,
    pub tv_usec: __u32,
    pub sequence: __u32,
    pub crtc_id: __u32,
}
#[test]
fn bindgen_test_layout_drm_event_vblank() {
    assert_eq!(
        ::core::mem::size_of::<drm_event_vblank>(),
        32usize,
        concat!("Size of: ", stringify!(drm_event_vblank))
    );
    assert_eq!(
        ::core::mem::align_of::<drm_event_vblank>(),
        8usize,
        concat!("Alignment of ", stringify!(drm_event_vblank))
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_event_vblank)).base as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_event_vblank),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_event_vblank)).user_data as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_event_vblank),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_event_vblank)).tv_sec as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_event_vblank),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_event_vblank)).tv_usec as *const _ as usize },
        20usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_event_vblank),
            "::",
            stringify!(tv_usec)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_event_vblank)).sequence as *const _ as usize },
        24usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_event_vblank),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const drm_event_vblank)).crtc_id as *const _ as usize },
        28usize,
        concat!(
            "Alignment of field: ",
            stringify!(drm_event_vblank),
            "::",
            stringify!(crtc_id)
        )
    );
}
impl Clone for drm_event_vblank {
    fn clone(&self) -> Self {
        *self
    }
}
pub type drm_clip_rect_t = drm_clip_rect;
pub type drm_drawable_info_t = drm_drawable_info;
pub type drm_tex_region_t = drm_tex_region;
pub type drm_hw_lock_t = drm_hw_lock;
pub type drm_version_t = drm_version;
pub type drm_unique_t = drm_unique;
pub type drm_list_t = drm_list;
pub type drm_block_t = drm_block;
pub type drm_control_t = drm_control;
pub use self::drm_map_type as drm_map_type_t;
pub use self::drm_map_flags as drm_map_flags_t;
pub type drm_ctx_priv_map_t = drm_ctx_priv_map;
pub type drm_map_t = drm_map;
pub type drm_client_t = drm_client;
pub use self::drm_stat_type as drm_stat_type_t;
pub type drm_stats_t = drm_stats;
pub use self::drm_lock_flags as drm_lock_flags_t;
pub type drm_lock_t = drm_lock;
pub use self::drm_dma_flags as drm_dma_flags_t;
pub type drm_buf_desc_t = drm_buf_desc;
pub type drm_buf_info_t = drm_buf_info;
pub type drm_buf_free_t = drm_buf_free;
pub type drm_buf_pub_t = drm_buf_pub;
pub type drm_buf_map_t = drm_buf_map;
pub type drm_dma_t = drm_dma;
pub type drm_wait_vblank_t = drm_wait_vblank;
pub type drm_agp_mode_t = drm_agp_mode;
pub use self::drm_ctx_flags as drm_ctx_flags_t;
pub type drm_ctx_t = drm_ctx;
pub type drm_ctx_res_t = drm_ctx_res;
pub type drm_draw_t = drm_draw;
pub type drm_update_draw_t = drm_update_draw;
pub type drm_auth_t = drm_auth;
pub type drm_irq_busid_t = drm_irq_busid;
pub use self::drm_vblank_seq_type as drm_vblank_seq_type_t;
pub type drm_agp_buffer_t = drm_agp_buffer;
pub type drm_agp_binding_t = drm_agp_binding;
pub type drm_agp_info_t = drm_agp_info;
pub type drm_scatter_gather_t = drm_scatter_gather;
pub type drm_set_version_t = drm_set_version;
pub const _DRM_MODE_PROP_SIGNED_RANGE: libc::c_uint = 128;
pub const DRM_MODE_PROP_SIGNED_RANGE: libc::c_uint = 128;
pub const _DRM_MODE_PROP_OBJECT: libc::c_uint = 64;
pub const DRM_MODE_PROP_OBJECT: libc::c_uint = 64;
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::core::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(0 as *const __va_list_tag)).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const __va_list_tag)).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const __va_list_tag)).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Alignment of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const __va_list_tag)).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Alignment of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self {
        *self
    }
}
impl Default for __va_list_tag {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
